<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   ::selection,a::selection{background:rgba(255,255,0,.3)}a,a::selection{color:#0645ad}hr,img{border:0}a,ins{text-decoration:none}::selection,ins,mark{color:#000}dfn,mark{font-style:italic}hr,ol,p,ul{margin:1em 0}table tr td,table tr th{border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}hr,pre code,table,table tr{padding:0}pre,pre code{white-space:pre}html{font-size:100%;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{color:#444;font-family:Georgia,Palatino,"Palatino Linotype",Times,"Times New Roman",serif;font-size:12px;line-height:1.5em;padding:1em;margin:auto;max-width:42em;background:#fefefe}a:visited{color:#0b0080}a:hover{color:#06e}a:active{color:#faa700}a:focus{outline:dotted thin}a:active,a:hover{outline:0}::-moz-selection{background:rgba(255,255,0,.3);color:#000}a::-moz-selection{background:rgba(255,255,0,.3);color:#0645ad}img{max-width:100%;-ms-interpolation-mode:bicubic;vertical-align:middle}h1,h2,h3,h4,h5,h6{font-weight:400;color:#111;line-height:1em}b,h4,h5,h6,mark,strong,table tr th{font-weight:700}h1{font-size:2.5em}h2{font-size:2em}h3{font-size:1.5em}h4{font-size:1.2em}h5{font-size:1em}h6{font-size:.9em}blockquote{color:#666;margin:0;padding-left:3em;border-left:.5em #EEE solid}hr{display:block;height:2px;border-top:1px solid #aaa;border-bottom:1px solid #eee}code,kbd,pre,samp{color:#000;font-family:monospace,monospace;font-size:.98em}pre{white-space:pre-wrap;word-wrap:break-word}ins{background:#ff9}mark{background:#ff0}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}ol,ul{padding:0 0 0 2em}li p:last-child{margin:0}dd{margin:0 0 0 2em}table{border-collapse:collapse;border-spacing:0}td{vertical-align:top}@media only screen and (min-width:480px){body{font-size:14px}}@media only screen and (min-width:768px){body{font-size:16px}}@media print{blockquote,img,pre,tr{page-break-inside:avoid}*{background:0 0!important;color:#000!important;filter:none!important;-ms-filter:none!important}body{font-size:12pt;max-width:100%}a,a:visited{text-decoration:underline}hr{height:1px;border:0;border-bottom:1px solid #000}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}blockquote,pre{border:1px solid #999;padding-right:1em}img{max-width:100%!important}@page :left{margin:15mm 20mm 15mm 10mm}@page :right{margin:15mm 10mm 15mm 20mm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;border:none;background:0 0}.highlight pre,pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}
  </style>
 </head>
 <body>
  <h1 id="10chapter-8-exceptional-control-flow">
  </h1>
  <p align="center">
   <strong>
    <font size="6">
     计算机系统篇之链接（10）：Chapter 8 Exceptional Control Flow 章节习题与解答
    </font>
   </strong>
  </p>
  <p align="right">
   Author:stormQ
  </p>
  <p align="right">
   Created: Saturday, 15. August 2020 01:38PM
  </p>
  <p align="right">
   Last Modified: Tuesday, 22. September 2020 07:12PM
  </p>
  <ul>
   <li>
    <h3 id="_1">
     目录
    </h3>
    <ul class="checklist">
     <li>
      <input checked="" disabled="" type="checkbox"/>
      <a href="#jump习题">
       习题
      </a>
     </li>
     <li>
      <input checked="" disabled="" type="checkbox"/>
      <a href="#jump解答">
       解答
      </a>
     </li>
    </ul>
   </li>
  </ul>
  <hr/>
  <h3 id="_2">
   <span id="jump习题">
    习题
   </span>
  </h3>
  <ul>
   <li>
    <span id="jump8_9题目">
     <strong>
      8.9
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.9_1.png"/>
   <br/>
   <img alt="" src="image/8.9_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_9解答">
    8.9 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_10题目">
     <strong>
      8.10
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.10_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_10解答">
    8.10 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_11题目">
     <strong>
      8.11
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.11_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_11解答">
    8.11 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_12题目">
     <strong>
      8.12
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.12_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_12解答">
    8.12 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_13题目">
     <strong>
      8.13
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.13_1.png"/>
   <br/>
   <img alt="" src="image/8.13_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_13解答">
    8.13 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_14题目">
     <strong>
      8.14
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.14_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_14解答">
    8.14 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_15题目">
     <strong>
      8.15
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.15_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_15解答">
    8.15 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_16题目">
     <strong>
      8.16
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.16_1.png"/>
   <br/>
   <img alt="" src="image/8.16_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_16解答">
    8.16 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_17题目">
     <strong>
      8.17
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.17_1.png"/>
   <br/>
   <img alt="" src="image/8.17_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_17解答">
    8.17 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_18题目">
     <strong>
      8.18
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.18_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_18解答">
    8.18 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_19题目">
     <strong>
      8.19
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.19_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_19解答">
    8.19 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_20题目">
     <strong>
      8.20
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.20_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_20解答">
    8.20 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_21题目">
     <strong>
      8.21
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.21_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_21解答">
    8.21 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_22题目">
     <strong>
      8.22
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.22_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_22解答">
    8.22 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_23题目">
     <strong>
      8.23
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.23_1.png"/>
   <br/>
   <img alt="" src="image/8.23_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_23解答">
    8.23 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_24题目">
     <strong>
      8.24
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.24_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_24解答">
    8.24 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_25题目">
     <strong>
      8.25
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.25_1.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_25解答">
    8.25 解答
   </a>
  </p>
  <hr/>
  <ul>
   <li>
    <span id="jump8_26题目">
     <strong>
      8.26
     </strong>
    </span>
   </li>
  </ul>
  <p>
   <img alt="" src="image/8.26_1.png"/>
   <br/>
   <img alt="" src="image/8.26_2.png"/>
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_26解答">
    8.26 解答
   </a>
  </p>
  <hr/>
  <h3 id="_3">
   <span id="jump解答">
    解答
   </span>
  </h3>
  <h4 id="89">
   <span id="jump8_9解答">
    8.9 解答
   </span>
  </h4>
  <p>
   判断两个进程是否并发地运行的依据为：两者的执行时间是否存在重叠。因此，该题的解答如下：
  </p>
  <table>
   <thead>
    <tr>
     <th>
      进程对
     </th>
     <th>
      是否并发地运行
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      AB
     </td>
     <td>
      否
     </td>
    </tr>
    <tr>
     <td>
      AC
     </td>
     <td>
      是
     </td>
    </tr>
    <tr>
     <td>
      AD
     </td>
     <td>
      是
     </td>
    </tr>
    <tr>
     <td>
      BC
     </td>
     <td>
      是
     </td>
    </tr>
    <tr>
     <td>
      BD
     </td>
     <td>
      是
     </td>
    </tr>
    <tr>
     <td>
      CD
     </td>
     <td>
      是
     </td>
    </tr>
   </tbody>
  </table>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_9题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="810">
   <span id="jump8_10解答">
    8.10 解答
   </span>
  </h4>
  <table>
   <thead>
    <tr>
     <th>
      函数
     </th>
     <th>
      返回行为
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      setjmp
     </td>
     <td>
      调用一次，返回一次或多次
     </td>
    </tr>
    <tr>
     <td>
      longjmp
     </td>
     <td>
      调用一次，从不返回
     </td>
    </tr>
    <tr>
     <td>
      execve
     </td>
     <td>
      调用一次，从不返回
     </td>
    </tr>
    <tr>
     <td>
      fork
     </td>
     <td>
      调用一次，返回两次
     </td>
    </tr>
   </tbody>
  </table>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_10题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="811">
   <span id="jump8_11解答">
    8.11 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 2，共生成了 4 个进程，每个进程都会打印一次“hello”。因此，“hello”输出行共 4 个。
  </p>
  <p>
   源码，main8_11.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

int main()
{
    int i;
    for (i = 0; i &lt; 2; i++)
    {
        fork();
    }
    std::printf("hello\n");
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_11 main8_11.cpp -g
$ ./main8_11
hello
hello
hello
hello
</code></pre>
  <p>
   通过实际运行程序可以发现，“hello”输出行的个数确实为 4。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_11题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="812">
   <span id="jump8_12解答">
    8.12 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 2，共生成了 4 个进程，每个进程都会打印两次“hello”。因此，“hello”输出行共 8 个。
  </p>
  <p>
   源码，main8_12.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void DoIt()
{
    fork();
    fork();
    std::printf("hello\n");
    return;
}

int main()
{
    DoIt();
    std::printf("hello\n");
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_12 main8_12.cpp -g
$ ./main8_12
hello
hello
hello
hello
hello
hello
hello
hello
</code></pre>
  <p>
   通过实际运行程序可以发现，“hello”输出行的个数确实为 8。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_12题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="813">
   <span id="jump8_13解答">
    8.13 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 1，共生成了 2 个进程。
  </p>
  <p>
   在父进程中，fork() 函数的返回值为子进程的 PID。因此，条件表达式
   <code>
    fork() != 0
   </code>
   的求值结果在父进程中为 true。也就是说，父进程执行的语句依次为：
   <code>
    std::printf("x=%d\n", ++x);
   </code>
   、
   <code>
    std::printf("x=%d\n", --x);
   </code>
   。即父进程的输出结果依次为：
   <code>
    x=4
   </code>
   、
   <code>
    x=3
   </code>
   。
  </p>
  <p>
   在子进程中，fork() 函数的返回值为 0。因此，条件表达式
   <code>
    fork() != 0
   </code>
   的求值结果在子进程中为 false。也就是说，子进程执行的语句只有
   <code>
    std::printf("x=%d\n", --x);
   </code>
   。即子进程的输出结果为：
   <code>
    x=2
   </code>
   。
  </p>
  <p>
   由于子进程继承了父进程打开的文件，并且父子进程的运行是独立互不影响的。因此，所有可能的输出结果有 3 个。
  </p>
  <p>
   输出结果 1：
  </p>
  <pre><code>x=2
x=4
x=3
</code></pre>
  <p>
   输出结果 2：
  </p>
  <pre><code>x=4
x=2
x=3
</code></pre>
  <p>
   输出结果 3：
  </p>
  <pre><code>x=4
x=3
x=2
</code></pre>
  <p>
   源码，main8_13.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

int main()
{
    int x = 3;
    if (fork() != 0)
    {
        std::printf("x=%d\n", ++x);
    }
    std::printf("x=%d\n", --x);
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_13 main8_13.cpp -g
$ ./main8_13 
x=4
x=3
x=2
</code></pre>
  <p>
   通过实际运行程序可以发现，程序的一种可能输出为
   <code>
    输出结果 3
   </code>
   。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_13题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="814">
   <span id="jump8_14解答">
    8.14 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 2，最多可生成 4 个进程。但是，第二次执行 fork() 函数的前提是条件表达式
   <code>
    fork() != 0
   </code>
   的求值结果为 ture。也就是说，父进程在调用第一个 fork() 函数后还会调用第二个 fork() 函数，而子进程不会调用第二个 fork() 函数。因此，实际的进程共 3 个。
  </p>
  <p>
   父进程在执行完
   <code>
    DoIt()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后就退出了。
  </p>
  <p>
   第一个子进程在执行完
   <code>
    main()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后就退出了。
  </p>
  <p>
   第二个子进程在执行完
   <code>
    DoIt()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后就退出了。
  </p>
  <p>
   因此，“hello”输出行共 3 个。
  </p>
  <p>
   源码，main8_14.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void DoIt()
{
    if (fork() != 0)
    {
        fork();
        std::printf("hello\n");
        return;
    }
    return;
}

int main()
{
    DoIt();
    std::printf("hello\n");
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_14 main8_14.cpp -g
$ ./main8_14 
hello
hello
hello
</code></pre>
  <p>
   通过实际运行程序可以发现，“hello”输出行的个数确实为 3。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_14题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="815">
   <span id="jump8_15解答">
    8.15 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 2，最多可生成 4 个进程。但是，第二次执行 fork() 函数的前提是条件表达式
   <code>
    fork() != 0
   </code>
   的求值结果为 ture。也就是说，父进程在调用第一个 fork() 函数后还会调用第二个 fork() 函数，而子进程不会调用第二个 fork() 函数。因此，实际的进程共 3 个。
  </p>
  <p>
   父进程在执行完
   <code>
    DoIt()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后，继续执行
   <code>
    main()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后退出。
  </p>
  <p>
   第一个子进程在执行完
   <code>
    main()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后就退出了。
  </p>
  <p>
   第二个子进程在执行完
   <code>
    DoIt()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后，继续执行
   <code>
    main()
   </code>
   函数中的：
   <code>
    std::printf("hello\n");
   </code>
   语句后退出。
  </p>
  <p>
   因此，“hello”输出行共 5 个。
  </p>
  <p>
   源码，main8_15.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void DoIt()
{
    if (fork() != 0)
    {
        fork();
        std::printf("hello\n");
        std::exit(0);
    }
    return;
}

int main()
{
    DoIt();
    std::printf("hello\n");
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_15 main8_15.cpp -g
$ ./main8_15 
hello
hello
hello
hello
hello
</code></pre>
  <p>
   通过实际运行程序可以发现，“hello”输出行的个数确实为 5。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_15题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="816">
   <span id="jump8_16解答">
    8.16 解答
   </span>
  </h4>
  <p>
   fork() 函数被调用的次数为 1，共生成了 2 个进程。
  </p>
  <p>
   在父进程中，fork() 函数的返回值为子进程的 PID。因此，条件表达式
   <code>
    fork() == 0
   </code>
   的求值结果在父进程中为 false。也就是说，父进程执行的语句依次为：wait(NULL);
   <code>
    、
   </code>
   std::printf(“counter=%d\n”, ++counter);
   <code>
    、
   </code>
   std::exit(0);`。
  </p>
  <p>
   在子进程中，fork() 函数的返回值为 0。因此，条件表达式
   <code>
    fork() == 0
   </code>
   的求值结果在子进程中为 true。也就是说，子进程执行的语句依次为：
   <code>
    counter--;
   </code>
   、
   <code>
    std::exit(0);
   </code>
   。
  </p>
  <p>
   由于父子进程的运行是独立互不影响的。也就是说，子进程对全局变量
   <code>
    counter
   </code>
   的修改对父进程来说是不可见的，因此，父进程中全局变量
   <code>
    counter
   </code>
   的最终值为 2。即程序的输出结果为
   <code>
    counter=2
   </code>
   。
  </p>
  <p>
   源码，main8_16.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

int counter = 1;

int main()
{
    if (fork() == 0)
    {
        counter--;
        std::exit(0);
    }
    else
    {
        wait(NULL);
        std::printf("counter=%d\n", ++counter);
    }
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_16 main8_16.cpp -g
$ ./main8_16 
counter=2
</code></pre>
  <p>
   通过实际运行程序可以发现，输出结果中全局变量
   <code>
    counter
   </code>
   的值确实为 2。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_16题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="817">
   <span id="jump8_17解答">
    8.17 解答
   </span>
  </h4>
  <p>
   练习题 8.4 的进程图为：
  </p>
  <pre><code>                             "1\n"    "Bye\n"    2
                      --------&gt;*--------&gt;*------&gt;*
                      |     printf    printf    exit
                      |                          |
                      |                          |
        "Hello\n"     |       "0\n"              v       "2\n"    "Bye\n"   2
  *--------&gt;*--------&gt;*--------&gt;*---------------&gt;*--------&gt;*--------&gt;*------&gt;*
main    printf      fork     printf          waitpid   printf    printf    exit
</code></pre>
  <p>
   所有可能的输出有以下 3 种。
  </p>
  <p>
   输出 1：
  </p>
  <pre><code>Hello
0
1
Bye
2
Bye
</code></pre>
  <p>
   输出 2：
  </p>
  <pre><code>Hello
1
0
Bye
2
Bye
</code></pre>
  <p>
   输出 3：
  </p>
  <pre><code>Hello
1
Bye
0
2
Bye
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_17题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="818">
   <span id="jump8_18解答">
    8.18 解答
   </span>
  </h4>
  <p>
   习题 8.18 的进程图为：
  </p>
  <pre><code>                                       "0"                             "2"
                               ------&gt;*------&gt;*--------&gt;*------&gt;*-----&gt;*----&gt;*
                               |   printf  fflush    exit     end  printf fflush
                               |
                               |      "1"                          "2"
            --------&gt;*--------&gt;*------&gt;*--------&gt;*--------&gt;*--------&gt;*-----&gt;*
            |     atexit     fork    printf    exit       end     printf  fflush
            |
            |                 "0"
            |         --------&gt;*--------&gt;*--------&gt;*
            |         |     printf    fflush     exit
            |         |
            |         |        "1"
  *--------&gt;*--------&gt;*--------&gt;*--------&gt;*
main      fork      fork     printf      exit
</code></pre>
  <p>
   <strong>
    注意：
   </strong>
   进程图中最上面的进程也会打印 2 的原因在于其父进程中设置了
   <code>
    exit 函数被调用时会调用的函数列表
   </code>
   ，它作为子进程拥有与父进程相同的函数列表。
  </p>
  <p>
   所有可能的输出有 24 种，即
   <code>
    02
   </code>
   、
   <code>
    12
   </code>
   、
   <code>
    0
   </code>
   、
   <code>
    1
   </code>
   全排列的结果。因此，可能的输出结果为 A、C、E。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_18题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="819">
   <span id="jump8_19解答">
    8.19 解答
   </span>
  </h4>
  <p>
   <img alt="" src="image/fork_1.png"/>
  </p>
  <p>
   源码，main8_19.cpp：
  </p>
  <pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void foo(int n)
{
    int i;
    for (i = 0; i &lt; n; i++)
    {
        fork();
    }
    std::printf("hello\n");
    std::exit(0);
}

int main(int argc, char* argv[])
{
    if (argc != 2)
    {
        std::printf("Usage: &lt;fork-called-count&gt;\n");
        std::exit(0);
    }
    foo(std::atoi(argv[1]));
    std::exit(0);
}
</code></pre>
  <p>
   生成并运行可执行目标文件 ：
  </p>
  <pre><code>$ g++ -o main8_19 main8_19.cpp -g
$ ./main8_19 1
hello
hello
$ ./main8_19 2
hello
hello
hello
hello
$ ./main8_19 3
hello
hello
hello
hello
hello
hello
hello
hello
</code></pre>
  <p>
   通过实际运行程序可以发现，n 分别为 1、2、3、10 时，输出个数分别为 2、4、8、1024。可以归纳出一个结论：如果 fork() 函数被调用的次数为 n，那么生成的进程数（包括所有的进程）为 2 的 n 次幂。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_19题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="820">
   <span id="jump8_20解答">
    8.20 解答
   </span>
  </h4>
  <p>
   实现方式 1：
  </p>
  <pre><code>#include &lt;unistd.h&gt;

int main(int argc, char *argv[], char *envp[])
{
    execve("/bin/ls", argv, envp);
    return 0;
}
</code></pre>
  <p>
   实现方式 2：
  </p>
  <pre><code>#include &lt;unistd.h&gt;

int main(int argc, char *argv[])
{
    execve("/bin/ls", argv, environ);
    return 0;
}
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_20题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="821">
   <span id="jump8_21解答">
    8.21 解答
   </span>
  </h4>
  <p>
   习题 8.21 的进程图为：
  </p>
  <pre><code>                   "a"
           --------&gt;*-------------------&gt;*
           |     printf                exit
           |                             |
           |                             |
           |        "b"                  V        "c"
 *--------&gt;*--------&gt;*--------&gt;*--------&gt;*--------&gt;*--------&gt;*--------&gt;*
main     fork      printf   fflush    waitpid   printf    fflush     exit
</code></pre>
  <p>
   所有可能的输出有以下 2 种。
  </p>
  <p>
   输出 1：
  </p>
  <pre><code>abc
</code></pre>
  <p>
   输出 2：
  </p>
  <pre><code>bac
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_21题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="822">
   <span id="jump8_22解答">
    8.22 解答
   </span>
  </h4>
  <p>
   mysystem 函数的实现：
  </p>
  <pre><code>int mysystem(char *command)
{
    char *myargv[4];
    myargv[0] = (char *)"/bin/bash";
    myargv[1] = (char *)"-c";
    myargv[2] = command;
    myargv[3] = NULL;

    if (fork() == 0)
    {
        execve(myargv[0], myargv, environ);
        std::printf("error:%s\n", command);
        exit(0);
    }

    int status = 0;
    Wait(&amp;status);
    if (WIFEXITED(status))
    {
        return WEXITSTATUS(status);
    }
    if (WIFSIGNALED(status))
    {
        return WTERMSIG(status);
    }
    return -1;
}
</code></pre>
  <p>
   执行一次
   <code>
    mysystem
   </code>
   函数，会导致两个进程被创建。一个是
   <code>
    /bin/bash
   </code>
   进程（父进程是执行
   <code>
    mysystem
   </code>
   函数的调用进程），一个是
   <code>
    command
   </code>
   进程（父进程是
   <code>
    /bin/bash
   </code>
   进程）。
  </p>
  <p>
   <strong>
    注意：
   </strong>
   <code>
    mysystem
   </code>
   函数中是通过
   <code>
    /bin/bash
   </code>
   执行 command 的。这是因为，通过
   <code>
    /bin/sh
   </code>
   执行 command 时，如果 command 程序自杀或通过信号杀死
   <code>
    command
   </code>
   进程时（都属于 command 异常退出的情况），父进程中
   <code>
    WIFEXITED(status)
   </code>
   的求值结果为 true，而通过
   <code>
    /bin/bash
   </code>
   执行时，其求值结果为 false。另外，如果通过
   <code>
    /bin/sh
   </code>
   执行 command，通过信号杀死
   <code>
    /bin/sh
   </code>
   进程时，父进程中
   <code>
    WIFEXITED(status)
   </code>
   的求值结果才会为 false。
  </p>
  <p>
   完整的程序实现，main8_22.cpp：
  </p>
  <pre><code>#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;errno.h&gt;
#include &lt;sstream&gt;

int Wait(int *status)
{
  int pid = 0;
  do
  {
    pid = wait(status);
  } while (-1 == pid &amp;&amp; EINTR == errno);
  return pid;
}

int mysystem(char *command)
{
    char *myargv[4];
    myargv[0] = (char *)"/bin/bash";
    myargv[1] = (char *)"-c";
    myargv[2] = command;
    myargv[3] = NULL;

    if (fork() == 0)
    {
        execve(myargv[0], myargv, environ);
        std::printf("error:%s\n", command);
        exit(0);
    }

    int status = 0;
    Wait(&amp;status);
    if (WIFEXITED(status))
    {
        return WEXITSTATUS(status);
    }
    if (WIFSIGNALED(status))
    {
        return WTERMSIG(status);
    }
    return -1;
}

int main(int argc, char *argv[])
{
    if (argc &lt; 2)
    {
        std::printf("Usage: ./main8_22 \"&lt;command&gt;\"\n");
        return 1;
    }
    const auto result = mysystem(argv[1]);
    std::printf("result of mysystem:%d\n", result);
    return 0;
}
</code></pre>
  <p>
   测试程序，main8_26.cpp：
  </p>
  <pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

int main(int argc, char *argv[])
{
    if (argc &lt; 2)
    {
        std::printf("Usage: ./main8_26 &lt;exit_status&gt;\n");
        std::printf("If exit_status &lt; 0, kill itself. Otherwise, returns exit_status\n");
        return 1;
    }
    if (std::atoi(argv[1]) &lt; 0)
    {
        kill(getpid(), SIGKILL);
    }
    return std::atoi(argv[1]);
}
</code></pre>
  <p>
   编译：
  </p>
  <pre><code>$ g++ -o main8_22 main8_22.cpp -g
$ g++ -o main8_26 main8_26.cpp -g
</code></pre>
  <p>
   运行，command 正常退出时：
  </p>
  <pre><code>$ ./main8_22 "./main8_26 1"
result of mysystem:1
</code></pre>
  <p>
   运行，command 异常退出时：
  </p>
  <pre><code>$ ./main8_22 "./main8_26 -1"
result of mysystem:9
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_22题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="823">
   <span id="jump8_23解答">
    8.23 解答
   </span>
  </h4>
  <p>
   子进程在发送第一个
   <code>
    SIGUSR2
   </code>
   信号后，父进程接收该信号并执行信号处理程序
   <code>
    handler
   </code>
   。在信号处理程序第一次运行期间，子进程发送了 4 个
   <code>
    SIGUSR2
   </code>
   信号，但父进程中
   <code>
    SIGUSR2
   </code>
   待处理信号的数量只有 1 个而不是相应地 4 个。这是因为，同一种类型的待处理信号至多有一个。在信号处理程序第一次运行完成后，内核发现还有一个
   <code>
    SIGUSR2
   </code>
   待处理信号，于是让父进程接收该信号并执行信号处理程序。所以，虽然子进程发送了 5 个
   <code>
    SIGUSR2
   </code>
   信号，但是父进程实际接收的信号数量为 2，即父进程中的信号处理程序一共调用了两次。因此，counter 的值是 2。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_23题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="824">
   <span id="jump8_24解答">
    8.24 解答
   </span>
  </h4>
  <p>
   源码，main8_24.cpp：
  </p>
  <pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sstream&gt;

void foo(int exit_status)
{
    if (0 == fork())
    {
        const char *str = "abcdef";
        char *p = (char *)&amp;str[0];
        *p = 'A';
        std::exit(exit_status);
    }
}

int main()
{
    for (int i = 0; i &lt; 5; i++)
    {
        foo(i);
    }

    int child_pid = 0, child_status = 0;
    while ((child_pid = wait(&amp;child_status)) &gt; 0)
    {
        if (WIFSIGNALED(child_status))
        {
            const auto sig = WTERMSIG(child_status);
            std::stringstream str;
            str &lt;&lt; "child " &lt;&lt; child_pid &lt;&lt; " terminated by signal " &lt;&lt; sig;
            psignal(sig, str.str().c_str());
        }
    }

    return 0;
}
</code></pre>
  <p>
   编译：
  </p>
  <pre><code>g++ -o main8_24 main8_24.cpp -g
</code></pre>
  <p>
   运行：
  </p>
  <pre><code>$ ./main8_24 
child 13156 terminated by signal 11: Segmentation fault
child 13154 terminated by signal 11: Segmentation fault
child 13153 terminated by signal 11: Segmentation fault
child 13161 terminated by signal 11: Segmentation fault
child 13158 terminated by signal 11: Segmentation fault
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_24题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="825">
   <span id="jump8_25解答">
    8.25 解答
   </span>
  </h4>
  <p>
   tfgets() 函数的实现：
  </p>
  <pre><code>char* tfgets (char *buf, int size, FILE *stream)
{
    SetSignalHanlder(SIGALRM, SigalrmHandler);
    alarm(5);
    if (1 == setjmp(env))
    {
        return NULL;
    }
    return std::fgets(buf, size, stream);
}
</code></pre>
  <p>
   完整的程序实现，main8_25.cpp：
  </p>
  <pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;setjmp.h&gt;

#define SIZE 128

jmp_buf env;

bool SetSignalHanlder(int sig, void (*hanlder)(int))
{
  struct sigaction sa;
  std::memset(&amp;sa, 0, sizeof(sa));
  sa.sa_handler = hanlder;
  sa.sa_flags = SA_RESTART; // restart syscalls if possible
  return 0 == sigaction(sig, &amp;sa, NULL);
}

void SigalrmHandler(int sig)
{
    if (SIGALRM != sig)
    {
        return;
    }
    longjmp(env, 1);
}

char* tfgets (char *buf, int size, FILE *stream)
{
    SetSignalHanlder(SIGALRM, SigalrmHandler);
    alarm(5);
    if (1 == setjmp(env))
    {
        return NULL;
    }
    return std::fgets(buf, size, stream);
}

int main()
{
    char buf[SIZE];
    char *input = tfgets(buf, SIZE, stdin);
    if (input)
    {
        std::printf("%s", input);
    }
    else
    {
        std::printf("tfgets returns NULL\n");
    }
    return 0;
}
</code></pre>
  <p>
   编译：
  </p>
  <pre><code>
</code></pre>
  <p>
   运行（用户在 5 秒内完成输入）：
  </p>
  <pre><code>$ ./main8_25 
1234
1234
</code></pre>
  <p>
   运行（用户在 5 秒内没有完成输入）：
  </p>
  <pre><code>$ ./main8_25 
1234tfgets returns NULL
</code></pre>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_25题目">
    返回题目
   </a>
  </p>
  <hr/>
  <h4 id="826">
   <span id="jump8_26解答">
    8.26 解答
   </span>
  </h4>
  <p>
   关于在前台和后台运行程序的功能实现，见
   <a href="https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%887%EF%BC%89%EF%BC%9A%E5%88%A9%E7%94%A8%20fork%20%E5%92%8C%20execve%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%20shell%20%E7%A8%8B%E5%BA%8F.html">
    计算机系统篇之异常控制流（7）：利用 fork 和 execve 实现一个简易的 shell 程序
   </a>
   ，其余功能暂未实现。
  </p>
  <p>
  </p>
  <p align="right">
   <a href="#jump8_26题目">
    返回题目
   </a>
  </p>
  <hr/>
  <p>
   <font size="4">
    <strong>
     下一篇：
    </strong>
    <a href="https://csstormq.github.io/#jump计算机系统">
     计算机系统之目录
    </a>
   </font>
  </p>
  <p>
   <font size="4">
    <strong>
     上一篇：
    </strong>
    <a href="https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%889%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%20FAQ">
     计算机系统篇之异常控制流（9）：异常控制流 FAQ ☆
    </a>
   </font>
  </p>
  <p>
  </p>
  <p align="center">
   <font size="4">
    <a href="https://csstormq.github.io">
     <strong>
      首页
     </strong>
    </a>
   </font>
  </p>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
