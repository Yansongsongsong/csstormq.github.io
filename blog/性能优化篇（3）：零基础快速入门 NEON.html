<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   ::selection,a::selection{background:rgba(255,255,0,.3)}a,a::selection{color:#0645ad}hr,img{border:0}a,ins{text-decoration:none}::selection,ins,mark{color:#000}dfn,mark{font-style:italic}hr,ol,p,ul{margin:1em 0}table tr td,table tr th{border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}hr,pre code,table,table tr{padding:0}pre,pre code{white-space:pre}html{font-size:100%;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{color:#444;font-family:Georgia,Palatino,"Palatino Linotype",Times,"Times New Roman",serif;font-size:12px;line-height:1.5em;padding:1em;margin:auto;max-width:42em;background:#fefefe}a:visited{color:#0b0080}a:hover{color:#06e}a:active{color:#faa700}a:focus{outline:dotted thin}a:active,a:hover{outline:0}::-moz-selection{background:rgba(255,255,0,.3);color:#000}a::-moz-selection{background:rgba(255,255,0,.3);color:#0645ad}img{max-width:100%;-ms-interpolation-mode:bicubic;vertical-align:middle}h1,h2,h3,h4,h5,h6{font-weight:400;color:#111;line-height:1em}b,h4,h5,h6,mark,strong,table tr th{font-weight:700}h1{font-size:2.5em}h2{font-size:2em}h3{font-size:1.5em}h4{font-size:1.2em}h5{font-size:1em}h6{font-size:.9em}blockquote{color:#666;margin:0;padding-left:3em;border-left:.5em #EEE solid}hr{display:block;height:2px;border-top:1px solid #aaa;border-bottom:1px solid #eee}code,kbd,pre,samp{color:#000;font-family:monospace,monospace;font-size:.98em}pre{white-space:pre-wrap;word-wrap:break-word}ins{background:#ff9}mark{background:#ff0}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}ol,ul{padding:0 0 0 2em}li p:last-child{margin:0}dd{margin:0 0 0 2em}table{border-collapse:collapse;border-spacing:0}td{vertical-align:top}@media only screen and (min-width:480px){body{font-size:14px}}@media only screen and (min-width:768px){body{font-size:16px}}@media print{blockquote,img,pre,tr{page-break-inside:avoid}*{background:0 0!important;color:#000!important;filter:none!important;-ms-filter:none!important}body{font-size:12pt;max-width:100%}a,a:visited{text-decoration:underline}hr{height:1px;border:0;border-bottom:1px solid #000}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}blockquote,pre{border:1px solid #999;padding-right:1em}img{max-width:100%!important}@page :left{margin:15mm 20mm 15mm 10mm}@page :right{margin:15mm 10mm 15mm 20mm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;border:none;background:0 0}.highlight pre,pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}
  </style>
 </head>
 <body>
  <h1 id="3-neon">
  </h1>
  <p align="center">
   <strong>
    <font size="6">
     性能优化篇（3）：零基础快速入门 NEON
    </font>
   </strong>
  </p>
  <p align="right">
   Author:stormQ
  </p>
  <p align="right">
   Created: Sunday, 24. November 2019 10:28PM
  </p>
  <p align="right">
   Last Modified: Wednesday, 28. October 2020 08:58PM
  </p>
  <hr/>
  <ul>
   <li>
    <h3 id="_1">
     目录
    </h3>
    <ul>
     <li>
      <p>
       <a href="#jump向量数据类型">
        向量数据类型
       </a>
      </p>
     </li>
     <li>
      <p>
       <a href="#jump向量赋值">
        向量赋值
       </a>
      </p>
     </li>
     <li>
      <p>
       <a href="#jump访问/存储向量的值">
        访问/存储向量的值
       </a>
      </p>
     </li>
     <li>
      <p>
       <a href="#jump向量算术逻辑运算">
        向量算术逻辑运算
       </a>
      </p>
     </li>
    </ul>
   </li>
  </ul>
  <hr/>
  <h3 id="_2">
   <span id="jump向量数据类型">
    向量数据类型
   </span>
  </h3>
  <ul>
   <li>
    语法格式
   </li>
  </ul>
  <p>
   向量类型：
  </p>
  <pre><code>&lt;type&gt;&lt;size&gt;&lt;number_of_lanes&gt;_t
</code></pre>
  <p>
   向量数组：
  </p>
  <pre><code>&lt;type&gt;&lt;size&gt;&lt;number_of_lanes&gt;&lt;length_of_array&gt;_t
</code></pre>
  <p>
   注：
   <code>
    type
   </code>
   ，表示数据类型，可选项：int（带符号整型）、uint（无符号整型）、float（浮点型）和 poly（多项式）。
   <code>
    size
   </code>
   ，表示一个元素占用多少 bit。
   <code>
    number_of_lanes
   </code>
   ，表示一个向量中包含的元素数量，第一个元素位于 lane[0] 的位置，第 n 个元素位于 lane[n-1] 的位置，lane[0] 对应向量寄存器最低位的
   <code>
    size
   </code>
   个 bit。
   <code>
    length_of_array
   </code>
   ，向量数组的大小。
  </p>
  <ul>
   <li>
    示例
   </li>
  </ul>
  <table>
   <thead>
    <tr>
     <th>
      向量类型
     </th>
     <th>
      含义
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      uint8x8_t
     </td>
     <td>
      一个包含八个元素，元素类型为 8-bit 无符号整型的向量
     </td>
    </tr>
    <tr>
     <td>
      uint8x8x2_t
     </td>
     <td>
      一个包含两个向量的向量数组，每个向量包含八个元素，元素类型为 8-bit 无符号整型
     </td>
    </tr>
   </tbody>
  </table>
  <hr/>
  <h3 id="_3">
   <span id="jump向量赋值">
    向量赋值
   </span>
  </h3>
  <ul>
   <li>
    <p>
     <a href="#jump向量常数赋值">
      向量常数赋值
     </a>
    </p>
   </li>
   <li>
    <p>
     <a href="#jump向量内存赋值">
      向量内存赋值
     </a>
    </p>
   </li>
   <li>
    <p>
     <a href="#jump向量单个元素内存赋值">
      向量单个元素内存赋值
     </a>
    </p>
   </li>
  </ul>
  <hr/>
  <h3 id="_4">
   <span id="jump向量常数赋值">
    向量常数赋值
   </span>
  </h3>
  <ul>
   <li>
    <p>
     <a href="#jumpuint8x8_t向量常数赋值（每个元素的值都相同）">
      uint8x8_t 向量常数赋值（每个元素的值都相同）
     </a>
    </p>
   </li>
   <li>
    <p>
     <a href="#jumpuint8x8_t向量常数赋值（每个元素的值可以不相同）">
      uint8x8_t 向量常数赋值（每个元素的值可以不同）
     </a>
    </p>
   </li>
  </ul>
  <p>
   <a href="#jump向量赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h4 id="uint8x8_t">
   <span id="jumpuint8x8_t向量常数赋值（每个元素的值都相同）">
    uint8x8_t 向量常数赋值（每个元素的值都相同）
   </span>
  </h4>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8x8_t vdup_n_u8(uint32_t a);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      将类型为
      <code>
       uint8x8_t
      </code>
      的向量中每个元素的值设置为参数
      <code>
       a
      </code>
      的值。
     </li>
    </ul>
   </li>
   <li>
    <p>
     注意事项
    </p>
    <ul>
     <li>
      参数
      <code>
       a
      </code>
      的值大于 255 时会发生”整型截断“；每个元素的赋值互不影响。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例，assign_uint8x8_t.cpp：
    </p>
   </li>
  </ul>
  <pre><code>#include "arm_neon.h"

int main()
{
    // 声明一个包含八个元素的向量，每个元素的数据类型为 uint8_t
    uint8x8_t a_uint8x8;
    // 将向量的每个元素赋值为 255
    a_uint8x8 = vdup_n_u8(255);
    return 0;
}
</code></pre>
  <p>
   注：使用
   <code>
    NEON Intrinsics
   </code>
   需要包含头文件
   <code>
    arm_neon.h
   </code>
   。
  </p>
  <ul>
   <li>
    编译（在 Linux ARM-64 位系统上）
   </li>
  </ul>
  <pre><code>$ g++ -std=c++11 -g -o assign_uint8x8_t assign_uint8x8_t.cpp
</code></pre>
  <ul>
   <li>
    代码调试（完整过程）
   </li>
  </ul>
  <pre><code>$ gdb -q ./assign_uint8x8_t
Reading symbols from ./assign_uint8x8_t...done.
(gdb) start
Temporary breakpoint 1 at 0x4005ac: file assign_uint8x8_t.cpp, line 8.
Starting program: /home/test/assign_uint8x8_t 

Temporary breakpoint 1, main () at assign_uint8x8_t.cpp:8
8       a_uint8x8 = vdup_n_u8(255);
(gdb) disas
Dump of assembler code for function main():
   0x00000000004005a0 &lt;+0&gt;: sub sp, sp, #0x10
   0x00000000004005a4 &lt;+4&gt;: mov w0, #0xffffffff             // #-1
   0x00000000004005a8 &lt;+8&gt;: strb    w0, [sp,#7]
=&gt; 0x00000000004005ac &lt;+12&gt;:    ldrb    w0, [sp,#7]
   0x00000000004005b0 &lt;+16&gt;:    dup v0.8b, w0
   0x00000000004005b4 &lt;+20&gt;:    str d0, [sp,#8]
   0x00000000004005b8 &lt;+24&gt;:    mov w0, #0x0                    // #0
   0x00000000004005bc &lt;+28&gt;:    add sp, sp, #0x10
   0x00000000004005c0 &lt;+32&gt;:    ret
End of assembler dump.
; 在语句 dup   v0.8b, w0 的下一条指令处设置断点，以观察 dup   v0.8b, w0 的执行效果
(gdb) b *0x00000000004005b4
Breakpoint 1 at 0x4005b4: file assign_uint8x8_t.cpp, line 8.
; 此时，还未执行 dup   v0.8b, w0。打印 v0 寄存器的值
(gdb) p $v0.b.u
$1 = {47 &lt;repeats 16 times&gt;}
(gdb) p $v0.b.u[0]
$2 = 47
(gdb) c
Continuing.

Breakpoint 2, main () at assign_uint8x8_t.cpp:8
8       a_uint8x8 = vdup_n_u8(255);
; 此时，已经执行了 dup  v0.8b, w0。打印 v0 寄存器的值
(gdb) p $v0.b.u
$3 = {255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0}
(gdb) p $v0.b.u[0]
$4 = 255
(gdb) p $v0.b.u[7]
$5 = 255
(gdb) p $v0.b.u[8]
$6 = 0
</code></pre>
  <p>
   可以看出 v0 寄存器的低位 8 字节分别被赋值为 255。
  </p>
  <p>
   <a href="#jump向量赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h4 id="uint8x8_t_1">
   <span id="jumpuint8x8_t向量常数赋值（每个元素的值可以不同）">
    uint8x8_t 向量常数赋值（每个元素的值可以不同）
   </span>
  </h4>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8x8_t vcreate_u8 (uint64_t __a);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      将参数
      <code>
       a
      </code>
      赋值给类型为
      <code>
       uint8x8_t
      </code>
      的向量。
     </li>
    </ul>
   </li>
   <li>
    <p>
     注意事项
    </p>
    <ul>
     <li>
      赋值顺序：参数
      <code>
       __a
      </code>
      的值从右到左每字节的内容依次赋值给向量的第一个元素到第八个元素（即
      <code>
       lane[0]
      </code>
      到
      <code>
       lane[7]
      </code>
      ）。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>void print_uint8x8_t(uint8x8_t val)
{
    std::printf("lane0=0x%x\n", vget_lane_u8(val, 0));
    std::printf("lane1=0x%x\n", vget_lane_u8(val, 1));
    std::printf("lane2=0x%x\n", vget_lane_u8(val, 2));
    std::printf("lane3=0x%x\n", vget_lane_u8(val, 3));
    std::printf("lane4=0x%x\n", vget_lane_u8(val, 4));
    std::printf("lane5=0x%x\n", vget_lane_u8(val, 5));
    std::printf("lane6=0x%x\n", vget_lane_u8(val, 6));
    std::printf("lane7=0x%x\n", vget_lane_u8(val, 7));
    std::printf("\n");
}

void assign_different_constant()
{
    std::printf("assign_different_constant function..............\n");

    uint8x8_t a_uint8x8 = vcreate_u8(0x12345678abcdef01);
    print_uint8x8_t(a_uint8x8);
}
</code></pre>
  <p>
   输出结果为：
  </p>
  <pre><code>assign_different_constant function..............
lane0=0x1
lane1=0xef
lane2=0xcd
lane3=0xab
lane4=0x78
lane5=0x56
lane6=0x34
lane7=0x12
</code></pre>
  <p>
   可以看出，参数
   <code>
    __a
   </code>
   的值从右到左每字节的内容依次赋值给向量的第一个元素到第八个元素。
  </p>
  <p>
   <a href="#jump向量赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="_5">
   <span id="jump向量内存赋值">
    向量内存赋值
   </span>
  </h3>
  <ul>
   <li>
    <p>
     <a href="#jumpuint8x8_t向量内存赋值">
      uint8x8_t 向量内存赋值
     </a>
    </p>
   </li>
   <li>
    <p>
     <a href="#jumpuint8x8x2_t向量内存赋值">
      uint8x8x2_t 向量内存赋值
     </a>
    </p>
   </li>
  </ul>
  <p>
   <a href="#jump向量赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h4 id="uint8x8_t_2">
   <span id="jumpuint8x8_t向量内存赋值">
    uint8x8_t 向量内存赋值
   </span>
  </h4>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8x8_t vld1_u8 (const uint8_t *a);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      将内存起始地址为
      <code>
       a
      </code>
      的后面八字节的内容赋值给类型为
      <code>
       uint8x8_t
      </code>
      的向量。
     </li>
    </ul>
   </li>
   <li>
    <p>
     注意事项
    </p>
    <ul>
     <li>
      如果参数
      <code>
       a
      </code>
      的有效元素数量小于8，那么会发生非法读。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>{
    // 源数据的有效元素数量等于8，合法
    uint8_t f_arr_uint8[] = {0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8};
    uint8x8_t f_uint8x8 = vld1_u8(f_arr_uint8);
    print_uint8x8_t(f_uint8x8);
}

{
    // 源数据的有效元素数量小于8，最后一个元素为非法读
    uint8_t a_arr_uint8[] = {0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8};
    uint8x8_t a_uint8x8 = vld1_u8(&amp;a_arr_uint8[1]);
    print_uint8x8_t(a_uint8x8);
}

{
    // 源数据的有效元素数量大于8，合法
    uint8_t b_arr_uint8[] = {0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 
                                0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf};
    uint8x8_t b_uint8x8 = vld1_u8(b_arr_uint8);
    print_uint8x8_t(b_uint8x8);
}

{
    // 源数据的有效元素数量小于8，第五个元素到第八个元素为非法读
    uint8_t c_arr_uint8[] = {0xc1, 0xc2, 0xc3, 0xc4};
    uint8x8_t c_uint8x8 = vld1_u8(c_arr_uint8);
    print_uint8x8_t(c_uint8x8);
}

{
    // 源数据的有效元素数量小于8，除第一个元素外其他元素为非法读
    uint8_t d_arr_uint8 = 0xd1;
    uint8x8_t d_uint8x8 = vld1_u8(&amp;d_arr_uint8);
    print_uint8x8_t(d_uint8x8);
}
</code></pre>
  <p>
   注：关于
   <code>
    print_uint8x8_t
   </code>
   函数的实现可以在其他示例中找到，此处省略。
  </p>
  <ul>
   <li>
    代码调试
   </li>
  </ul>
  <pre><code>(gdb) x/b &amp;a_arr_uint8[0]+8
0x7ffffff320:   0xff
; 打印 uint8x8_t a_uint8x8 = vld1_u8(&amp;a_arr_uint8[1]); 执行的结果
(gdb) p/x $v0.b.u
$4 = {0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
; 可以看出v0.b.u[7]的值为0xff，即内存地址为&amp;a_arr_uint8[0]+8的值。验证了最后一个元素为非法读。

(gdb) x/4b c_arr_uint8+4
0x7ffffff31c:   0xb4    0xb5    0xb6    0xb7
; 打印 uint8x8_t c_uint8x8 = vld1_u8(c_arr_uint8); 执行的结果
(gdb) display/x $v0.b.u
1: /x $v0.b.u = {0xc1, 0xc2, 0xc3, 0xc4, 0xb4, 0xb5, 0xb6, 0xb7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
; 可以看出v0.b.u[4]、v0.b.u[5]、v0.b.u[6]、v0.b.u[7]的值分别为0xb4、 0xb5、 0xb6、 0xb7，
; 即内存起始地址为c_arr_uint8+4后面4字节的值。验证了第五个元素到第八个元素为非法读。

(gdb) x/7b &amp;d_arr_uint8+1
0x7ffffff2c8:   0x19    0xf3    0xff    0xff    0x7f    0x00    0x00
; 打印 uint8x8_t d_uint8x8 = vld1_u8(&amp;d_arr_uint8); 执行的结果
(gdb) display/x $v0.b.u
1: /x $v0.b.u = {0xd1, 0x19, 0xf3, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
2: /x $v0.b.u = {0xd1, 0x19, 0xf3, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
; 可以看出v0.b.u[1]、v0.b.u[2]、v0.b.u[3]、v0.b.u[4]、v0.b.u[5]、v0.b.u[6]、v0.b.u[7]的值
; 分别为0x19、 0xf3、 0xff、 0xff、 0x7f、 0x0、 0x0，即内存起始地址为&amp;d_arr_uint8+1后面7字节的值。
; 验证了除第一个元素外其他元素为非法读。
</code></pre>
  <p>
   上述示例验证了：
   <code>
    vld1_u8()函数作用是将参数的值作为内存起始地址，无条件地将其后面的八字节的值赋值给向量。但如果源数据的有效元素数量小于8，会发生非法读
   </code>
   。
  </p>
  <p>
   <a href="#jump向量内存赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h4 id="uint8x8x2_t">
   <span id="jumpuint8x8x2_t向量内存赋值">
    uint8x8x2_t 向量内存赋值
   </span>
  </h4>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8x8x2_t vld2_u8 (const uint8_t * __a);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      内存地址为
      <code>
       __a、__a+2、__a+4、... __a+14
      </code>
      的内容分别赋值给第一个向量的
      <code>
       lane[0]、lane[1]、...、lane[7]
      </code>
      ，内存地址为
      <code>
       __a+1、__a+3、__a+5、... __a+15
      </code>
      的内容分别赋值给第二个向量的
      <code>
       lane[0]、lane[1]、...、lane[7]
      </code>
      。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>void print_uint8x8_t(uint8x8_t val)
{
    std::printf("lane0=0x%x\n", vget_lane_u8(val, 0));
    std::printf("lane1=0x%x\n", vget_lane_u8(val, 1));
    std::printf("lane2=0x%x\n", vget_lane_u8(val, 2));
    std::printf("lane3=0x%x\n", vget_lane_u8(val, 3));
    std::printf("lane4=0x%x\n", vget_lane_u8(val, 4));
    std::printf("lane5=0x%x\n", vget_lane_u8(val, 5));
    std::printf("lane6=0x%x\n", vget_lane_u8(val, 6));
    std::printf("lane7=0x%x\n", vget_lane_u8(val, 7));
    std::printf("\n");
}

void print_uint8x8x2_t(uint8x8x2_t data)
{
    std::printf("print val[0] ...\n");
    print_uint8x8_t(data.val[0]);
    std::printf("print val[1] ...\n");
    print_uint8x8_t(data.val[1]);
}

void assign_from_mem()
{
    std::printf("assign_from_mem function..............\n");

    uint8_t arr_uint8[] = {0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 
                            0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8};
    uint8x8x2_t a_uint8x8x2 = vld2_u8(arr_uint8);
    print_uint8x8x2_t(a_uint8x8x2);
}
</code></pre>
  <p>
   输出结果为：
  </p>
  <pre><code>assign_from_mem function..............
print val[0] ...
lane0=0xe1
lane1=0xe3
lane2=0xe5
lane3=0xe7
lane4=0xf1
lane5=0xf3
lane6=0xf5
lane7=0xf7

print val[1] ...
lane0=0xe2
lane1=0xe4
lane2=0xe6
lane3=0xe8
lane4=0xf2
lane5=0xf4
lane6=0xf6
lane7=0xf8
</code></pre>
  <p>
   <a href="#jump向量内存赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="_6">
   <span id="jump向量单个元素内存赋值">
    向量单个元素内存赋值
   </span>
  </h3>
  <ul>
   <li>
    <a href="#jumpuint8x8_t向量单个元素内存赋值">
     uint8x8_t 向量单个元素内存赋值
    </a>
   </li>
  </ul>
  <p>
   <a href="#jump向量赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="uint8x8_t_3">
   <span id="jumpuint8x8_t向量单个元素内存赋值">
    uint8x8_t 向量单个元素内存赋值
   </span>
  </h3>
  <ul>
   <li>
    宏定义
   </li>
  </ul>
  <pre><code>#define vld1_lane_u8(a, b, c)
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      设置向量中指定元素的值，而不改变其他元素的值。参数
      <code>
       a
      </code>
      为指向数据类型为
      <code>
       uint8_t
      </code>
      的指针；参数
      <code>
       b
      </code>
      为指向数据类型为
      <code>
       uint8x8_t
      </code>
      的向量；参数
      <code>
       c
      </code>
      为向量中元素的索引，合法范围为
      <code>
       0 &lt;= c &lt;=7
      </code>
      。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>void print_uint8x8_t(uint8x8_t val)
{
    std::printf("lane0=0x%x\n", vget_lane_u8(val, 0));
    std::printf("lane1=0x%x\n", vget_lane_u8(val, 1));
    std::printf("lane2=0x%x\n", vget_lane_u8(val, 2));
    std::printf("lane3=0x%x\n", vget_lane_u8(val, 3));
    std::printf("lane4=0x%x\n", vget_lane_u8(val, 4));
    std::printf("lane5=0x%x\n", vget_lane_u8(val, 5));
    std::printf("lane6=0x%x\n", vget_lane_u8(val, 6));
    std::printf("lane7=0x%x\n", vget_lane_u8(val, 7));
    std::printf("\n");
}

void assign_lane()
{
    std::printf("assign_lane function..............\n");

    uint8_t a_arr_uint8[] = {0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8};
    uint8x8_t a_uint8x8;

    std::printf("set lane[0] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8, a_uint8x8, 0);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[1] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 1, a_uint8x8, 1);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[2] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 2, a_uint8x8, 2);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[3] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 3, a_uint8x8, 3);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[4] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 4, a_uint8x8, 4);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[5] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 5, a_uint8x8, 5);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[6] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 6, a_uint8x8, 6);
    print_uint8x8_t(a_uint8x8);

    std::printf("set lane[7] ...\n");
    a_uint8x8 = vld1_lane_u8(a_arr_uint8 + 7, a_uint8x8, 7);
    print_uint8x8_t(a_uint8x8);
}
</code></pre>
  <p>
   输出结果为：
  </p>
  <pre><code>assign_lane function..............
set lane[0] ...
lane0=0xa1
lane1=0xed
lane2=0x21
lane3=0xe3
lane4=0x7f
lane5=0x0
lane6=0x0
lane7=0x0

set lane[1] ...
lane0=0xa1
lane1=0xa2
lane2=0x21
lane3=0xe3
lane4=0x7f
lane5=0x0
lane6=0x0
lane7=0x0

set lane[2] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xe3
lane4=0x7f
lane5=0x0
lane6=0x0
lane7=0x0

set lane[3] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xa4
lane4=0x7f
lane5=0x0
lane6=0x0
lane7=0x0

set lane[4] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xa4
lane4=0xa5
lane5=0x0
lane6=0x0
lane7=0x0

set lane[5] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xa4
lane4=0xa5
lane5=0xa6
lane6=0x0
lane7=0x0

set lane[6] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xa4
lane4=0xa5
lane5=0xa6
lane6=0xa7
lane7=0x0

set lane[7] ...
lane0=0xa1
lane1=0xa2
lane2=0xa3
lane3=0xa4
lane4=0xa5
lane5=0xa6
lane6=0xa7
lane7=0xa8
</code></pre>
  <p>
   <a href="#jump向量单个元素内存赋值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="_7">
   <span id="jump访问/存储向量的值">
    访问/存储向量的值
   </span>
  </h3>
  <ul>
   <li>
    <p>
     <a href="#jump访问uint8x8_t的值">
      访问 uint8x8_t 的值
     </a>
    </p>
   </li>
   <li>
    <p>
     <a href="#jump存储uint8x8_t的值">
      存储 uint8x8_t 的值
     </a>
    </p>
   </li>
  </ul>
  <hr/>
  <h3 id="uint8x8_t_4">
   <span id="jump访问uint8x8_t的值">
    访问 uint8x8_t 的值
   </span>
  </h3>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8_t vget_lane_u8(uint8x8_t __a, const int __b);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      返回类型为
      <code>
       uint8x8_t
      </code>
      向量（由参数
      <code>
       __a
      </code>
      确定）的第
      <code>
       n
      </code>
      个元素（由参数
      <code>
       __b
      </code>
      确定）的值。
     </li>
    </ul>
   </li>
   <li>
    <p>
     注意事项
    </p>
    <ul>
     <li>
      <p>
       参数
       <code>
        __b
       </code>
       指明访问向量中第几个元素的值，有效范围为
       <code>
        0 &lt;= b &lt;= 7
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       如果参数
       <code>
        __b
       </code>
       的值不在有效范围，在编译时会报如下错误——
       <code>
        error: lane 8 out of range 0 - 7
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       参数
       <code>
        __b
       </code>
       的值必须在编译期确定。也就是说，参数
       <code>
        __b
       </code>
       只能是常数。如果不是，编译时会报如下错误——
       <code>
        error: lane index must be a constant immediate
       </code>
       。
      </p>
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>// 声明一个包含八个元素的向量，每个元素的数据类型为 uint8_t
uint8x8_t a_uint8x8;
// 将向量的每个元素赋值为 255
a_uint8x8 = vdup_n_u8(255);

// 分别打印变量 a_uint8x8 的八个元素的值（十六进制）
std::printf("a_uint8x8: lane0=0x%x\n", vget_lane_u8(a_uint8x8, 0));
std::printf("a_uint8x8: lane1=0x%x\n", vget_lane_u8(a_uint8x8, 1));
std::printf("a_uint8x8: lane2=0x%x\n", vget_lane_u8(a_uint8x8, 2));
std::printf("a_uint8x8: lane3=0x%x\n", vget_lane_u8(a_uint8x8, 3));
std::printf("a_uint8x8: lane4=0x%x\n", vget_lane_u8(a_uint8x8, 4));
std::printf("a_uint8x8: lane5=0x%x\n", vget_lane_u8(a_uint8x8, 5));
std::printf("a_uint8x8: lane6=0x%x\n", vget_lane_u8(a_uint8x8, 6));
std::printf("a_uint8x8: lane7=0x%x\n", vget_lane_u8(a_uint8x8, 7));
</code></pre>
  <p>
   输出结果为：
  </p>
  <pre><code>a_uint8x8: lane0=0xff
a_uint8x8: lane1=0xff
a_uint8x8: lane2=0xff
a_uint8x8: lane3=0xff
a_uint8x8: lane4=0xff
a_uint8x8: lane5=0xff
a_uint8x8: lane6=0xff
a_uint8x8: lane7=0xff
</code></pre>
  <p>
   <a href="#jump访问/存储向量的值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="uint8x8_t_5">
   <span id="jump存储uint8x8_t的值">
    存储 uint8x8_t 的值
   </span>
  </h3>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>void vst1_u8 (uint8_t *a, uint8x8_t b);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      将类型为
      <code>
       uint8x8_t
      </code>
      向量（由参数
      <code>
       b
      </code>
      确定）的值存储到内存起始地址为
      <code>
       a
      </code>
      后面八字节的内存中。
     </li>
    </ul>
   </li>
   <li>
    <p>
     注意事项
    </p>
    <ul>
     <li>
      参数
      <code>
       a
      </code>
      所指向的合法内存必须不小于八字节，否则会产生非法写。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>void store_uint8x8_t(uint8x8_t val_uint8x8)
{
    {
        // 目的数据的元素数量等于8，合法
        uint8_t f_arr_uint8[] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8};
        std::printf("f_arr_uint8 ...\n");
        vst1_u8(f_arr_uint8, val_uint8x8);
    }

    {
        // 目的数据的元素数量等于8，但参数不是首元素的地址，最后一个元素为非法写
        uint8_t a_arr_uint8[] = {0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8};
        std::printf("a_arr_uint8 ...\n");
        vst1_u8(&amp;a_arr_uint8[1], val_uint8x8);
    }

    {
        // 目的数据的元素数量大于8，只写数组b_arr_uint8的前八个元素，合法
        uint8_t b_arr_uint8[] = {0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 
                                    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf};
        std::printf("b_arr_uint8 ...\n");
        vst1_u8(b_arr_uint8, val_uint8x8);
    }

    {
        // 目的数据的元素数量小于8，最后四个元素为非法写
        uint8_t c_arr_uint8[] = {0xc1, 0xc2, 0xc3, 0xc4};
        std::printf("c_arr_uint8 ...\n");
        vst1_u8(c_arr_uint8, val_uint8x8);
    }

    {
        // 目的数据是标量，最后七个元素为非法写
        uint8_t d_arr_uint8 = 0xd1;
        std::printf("d_arr_uint8 ...\n");
        vst1_u8(&amp;d_arr_uint8, val_uint8x8);
    }
}
</code></pre>
  <p>
   注：参数
   <code>
    val_uint8x8
   </code>
   的值为：{0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8}，参数
   <code>
    val_uint8x8
   </code>
   的值为：{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}。
  </p>
  <ul>
   <li>
    代码调试
   </li>
  </ul>
  <pre><code>(gdb) p/x &amp;f_arr_uint8[0]
$1 = 0x7ffffff2c8
(gdb) display/9ubx 0x7ffffff2c8
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0x01    0x02    0x03    0x04    0x05    0x06    0x07    0x08
0x7ffffff2d0:   0xf1
(gdb) n
f_arr_uint8 ...
34          vst1_u8(f_arr_uint8, val_uint8x8);
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0x01    0x02    0x03    0x04    0x05    0x06    0x07    0x08
0x7ffffff2d0:   0xf1
(gdb) n
39          uint8_t a_arr_uint8[] = {0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8};
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xf1    0xf2    0xf3    0xf4    0xf5    0xf6    0xf7    0xf8
0x7ffffff2d0:   0xf1
; 可以看出，“第九个元素”（0x7ffffff2d0处的内容）没有被修改，验证了目的数据的元素数量等于8，合法。


(gdb) n
40          std::printf("a_arr_uint8 ...\n");
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xa1    0xa2    0xa3    0xa4    0xa5    0xa6    0xa7    0xa8
0x7ffffff2d0:   0xf1
(gdb) 
a_arr_uint8 ...
41          vst1_u8(&amp;a_arr_uint8[1], val_uint8x8);
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xa1    0xa2    0xa3    0xa4    0xa5    0xa6    0xa7    0xa8
0x7ffffff2d0:   0xf1
(gdb) 
47                                      0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf};
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xa1    0xf1    0xf2    0xf3    0xf4    0xf5    0xf6    0xf7
0x7ffffff2d0:   0xf8
; 可以看出，“第八个元素”（0x7ffffff2d0处的内容）的值由0xf1变成了0xf8，但这个元素不是有效的，发生了非法写。


(gdb) n
48          std::printf("b_arr_uint8 ...\n");
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xb0    0xb1    0xb2    0xb3    0xb4    0xb5    0xb6    0xb7
0x7ffffff2d0:   0xb8
(gdb) 
b_arr_uint8 ...
49          vst1_u8(b_arr_uint8, val_uint8x8);
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xb0    0xb1    0xb2    0xb3    0xb4    0xb5    0xb6    0xb7
0x7ffffff2d0:   0xb8
(gdb) 
54          uint8_t c_arr_uint8[] = {0xc1, 0xc2, 0xc3, 0xc4};
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xf1    0xf2    0xf3    0xf4    0xf5    0xf6    0xf7    0xf8
0x7ffffff2d0:   0xb8
(gdb) x/16ubx 0x7ffffff2c8
0x7ffffff2c8:   0xf1    0xf2    0xf3    0xf4    0xf5    0xf6    0xf7    0xf8
0x7ffffff2d0:   0xb8    0xb9    0xba    0xbb    0xbc    0xbd    0xbe    0xbf
; 可以看出，只有b_arr_uint8的前八个元素被修改了，合法


(gdb) n
55          std::printf("c_arr_uint8 ...\n");
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xc1    0xc2    0xc3    0xc4    0xf5    0xf6    0xf7    0xf8
0x7ffffff2d0:   0xb8
(gdb) 
c_arr_uint8 ...
56          vst1_u8(c_arr_uint8, val2_uint8x8);
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0xc1    0xc2    0xc3    0xc4    0xf5    0xf6    0xf7    0xf8
0x7ffffff2d0:   0xb8
(gdb) 
61          uint8_t d_arr_uint8 = 0xd1;
1: x/9xb 0x7ffffff2c8
0x7ffffff2c8:   0x01    0x02    0x03    0x04    0x05    0x06    0x07    0x08
0x7ffffff2d0:   0xb8
; 可以看出，c_arr_uint8[3]后面的四个元素被修改了，但这几个元素不是有效的，发生了非法写。


(gdb) undisplay 
Delete all auto-display expressions? (y or n) y
(gdb) n
61          uint8_t d_arr_uint8 = 0xd1;
(gdb) 
62          std::printf("d_arr_uint8 ...\n");
(gdb) p/x &amp;d_arr_uint8
$1 = 0x7ffffff277
(gdb) display/8ubx 0x7ffffff277
1: x/8xb 0x7ffffff277
0x7ffffff277:   0xd1    0xc9    0xf2    0xff    0xff    0x7f    0x00    0x00
(gdb) n
d_arr_uint8 ...
63          vst1_u8(&amp;d_arr_uint8, val_uint8x8);
1: x/8xb 0x7ffffff277
0x7ffffff277:   0xd1    0xc9    0xf2    0xff    0xff    0x7f    0x00    0x00
(gdb) 
65  }
1: x/8xb 0x7ffffff277
0x7ffffff277:   0xf1    0xf2    0xf3    0xf4    0xf5    0xf6    0xf7    0xf8
; 可以看出，&amp;d_arr_uint8后面的七个元素被修改了，但这几个元素不是有效的，发生了非法写。
</code></pre>
  <p>
   <a href="#jump访问/存储向量的值">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="_8">
   <span id="jump向量算术逻辑运算">
    向量算术逻辑运算
   </span>
  </h3>
  <ul>
   <li>
    <a href="#jump向量加法运算">
     向量加法运算
    </a>
   </li>
  </ul>
  <hr/>
  <h3 id="_9">
   <span id="jump向量加法运算">
    向量加法运算
   </span>
  </h3>
  <ul>
   <li>
    <a href="#jump两个uint8x8_t相加">
     两个 uint8x8_t 相加
    </a>
   </li>
  </ul>
  <p>
   <a href="#jump向量算术逻辑运算">
    返回上一级
   </a>
  </p>
  <hr/>
  <h3 id="uint8x8_t_6">
   <span id="jump两个uint8x8_t相加">
    两个 uint8x8_t 相加
   </span>
  </h3>
  <ul>
   <li>
    函数原型
   </li>
  </ul>
  <pre><code>uint8x8_t vadd_u8(uint8x8_t a, uint8x8_t b);
</code></pre>
  <ul>
   <li>
    <p>
     作用
    </p>
    <ul>
     <li>
      将两个类型为
      <code>
       uint8x8_t
      </code>
      向量的对应位置元素相加，任意对应位置元素相加的结果（可能会进位或溢出）不会影响其他位置相加的结果。
     </li>
    </ul>
   </li>
   <li>
    <p>
     代码示例
    </p>
   </li>
  </ul>
  <pre><code>uint8x8_t a_uint8x8, b_uint8x8;
a_uint8x8 = vdup_n_u8(0x12);
b_uint8x8 = vdup_n_u8(0x34);

uint8x8_t sum_uint8x8;
sum_uint8x8 = vadd_u8(a_uint8x8, b_uint8x8);

// 分别打印变量 sum_uint8x8 的八个元素的值（十六进制）
std::printf("sum_uint8x8: lane0=0x%x\n", vget_lane_u8(sum_uint8x8, 0));
std::printf("sum_uint8x8: lane1=0x%x\n", vget_lane_u8(sum_uint8x8, 1));
std::printf("sum_uint8x8: lane2=0x%x\n", vget_lane_u8(sum_uint8x8, 2));
std::printf("sum_uint8x8: lane3=0x%x\n", vget_lane_u8(sum_uint8x8, 3));
std::printf("sum_uint8x8: lane4=0x%x\n", vget_lane_u8(sum_uint8x8, 4));
std::printf("sum_uint8x8: lane5=0x%x\n", vget_lane_u8(sum_uint8x8, 5));
std::printf("sum_uint8x8: lane6=0x%x\n", vget_lane_u8(sum_uint8x8, 6));
std::printf("sum_uint8x8: lane7=0x%x\n", vget_lane_u8(sum_uint8x8, 7));
</code></pre>
  <p>
   输出结果为：
  </p>
  <pre><code>sum_uint8x8: lane0=0x46
sum_uint8x8: lane1=0x46
sum_uint8x8: lane2=0x46
sum_uint8x8: lane3=0x46
sum_uint8x8: lane4=0x46
sum_uint8x8: lane5=0x46
sum_uint8x8: lane6=0x46
sum_uint8x8: lane7=0x46
</code></pre>
  <p>
   <a href="#jump向量加法运算">
    返回上一级
   </a>
  </p>
  <hr/>
  <p>
   <font size="4">
    <strong>
     下一篇：
    </strong>
    <a href="https://csstormq.github.io/blog/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%884%EF%BC%89%EF%BC%9ANEON%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B9%8BRGB%E5%88%B0BGR%EF%BC%88aarch64%E7%89%88%EF%BC%89">
     性能优化篇（4）：NEON优化案例——图像转换之RGB到BGR（aarch64版）
    </a>
   </font>
  </p>
  <p>
   <font size="4">
    <strong>
     上一篇：
    </strong>
    <a href="https://csstormq.github.io/blog/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%882%EF%BC%89%EF%BC%9A%E5%B0%8F%E5%BF%83%E2%80%9CSTL%20%E4%BD%8E%E6%95%88%E7%8E%87%E7%94%A8%E6%B3%95%E2%80%9D%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80">
     性能优化篇（2）：小心“STL 低效率用法”所带来的性能开销
    </a>
   </font>
  </p>
  <p>
  </p>
  <p align="center">
   <font size="4">
    <a href="https://csstormq.github.io">
     <strong>
      首页
     </strong>
    </a>
   </font>
  </p>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
