<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   ::selection,a::selection{background:rgba(255,255,0,.3)}a,a::selection{color:#0645ad}hr,img{border:0}a,ins{text-decoration:none}::selection,ins,mark{color:#000}dfn,mark{font-style:italic}hr,ol,p,ul{margin:1em 0}table tr td,table tr th{border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}hr,pre code,table,table tr{padding:0}pre,pre code{white-space:pre}html{font-size:100%;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{color:#444;font-family:Georgia,Palatino,"Palatino Linotype",Times,"Times New Roman",serif;font-size:12px;line-height:1.5em;padding:1em;margin:auto;max-width:42em;background:#fefefe}a:visited{color:#0b0080}a:hover{color:#06e}a:active{color:#faa700}a:focus{outline:dotted thin}a:active,a:hover{outline:0}::-moz-selection{background:rgba(255,255,0,.3);color:#000}a::-moz-selection{background:rgba(255,255,0,.3);color:#0645ad}img{max-width:100%;-ms-interpolation-mode:bicubic;vertical-align:middle}h1,h2,h3,h4,h5,h6{font-weight:400;color:#111;line-height:1em}b,h4,h5,h6,mark,strong,table tr th{font-weight:700}h1{font-size:2.5em}h2{font-size:2em}h3{font-size:1.5em}h4{font-size:1.2em}h5{font-size:1em}h6{font-size:.9em}blockquote{color:#666;margin:0;padding-left:3em;border-left:.5em #EEE solid}hr{display:block;height:2px;border-top:1px solid #aaa;border-bottom:1px solid #eee}code,kbd,pre,samp{color:#000;font-family:monospace,monospace;font-size:.98em}pre{white-space:pre-wrap;word-wrap:break-word}ins{background:#ff9}mark{background:#ff0}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}ol,ul{padding:0 0 0 2em}li p:last-child{margin:0}dd{margin:0 0 0 2em}table{border-collapse:collapse;border-spacing:0}td{vertical-align:top}@media only screen and (min-width:480px){body{font-size:14px}}@media only screen and (min-width:768px){body{font-size:16px}}@media print{blockquote,img,pre,tr{page-break-inside:avoid}*{background:0 0!important;color:#000!important;filter:none!important;-ms-filter:none!important}body{font-size:12pt;max-width:100%}a,a:visited{text-decoration:underline}hr{height:1px;border:0;border-bottom:1px solid #000}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}blockquote,pre{border:1px solid #999;padding-right:1em}img{max-width:100%!important}@page :left{margin:15mm 20mm 15mm 10mm}@page :right{margin:15mm 10mm 15mm 20mm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;border:none;background:0 0}.highlight pre,pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}
  </style>
 </head>
 <body>
  <h1 id="6neon-aarch64">
  </h1>
  <p align="center">
   <strong>
    <font size="6">
     性能优化篇（6）：NEON 优化案例——低阶矩阵乘法（aarch64版）
    </font>
   </strong>
  </p>
  <p align="right">
   Author:stormQ
  </p>
  <p align="right">
   Created: Sunday, 15. December 2019 1 08:21AM
  </p>
  <p align="right">
   Last Modified: Wednesday, 28. October 2020 09:21PM
  </p>
  <hr/>
  <ul>
   <li>
    <h3 id="_1">
     目录
    </h3>
    <ul>
     <li>
      <p>
       <a href="#jump使用Eigen库实现一个4阶方阵的乘法运算">
        使用 Eigen 库实现一个 4 阶方阵的乘法运算
       </a>
      </p>
     </li>
     <li>
      <p>
       <a href="#jump使用NEON实现一个4阶方阵的乘法运算">
        使用 NEON 实现一个 4 阶方阵的乘法运算
       </a>
      </p>
     </li>
    </ul>
   </li>
  </ul>
  <hr/>
  <h3 id="eigen-4">
   <span id="jump使用Eigen库实现一个4阶方阵的乘法运算">
    使用 Eigen 库实现一个 4 阶方阵的乘法运算
   </span>
  </h3>
  <p>
   首先，使用 Eigen 库实现一个 4 阶方阵的乘法运算，作为性能对比测试的参照。完整实现如下：
  </p>
  <pre><code>#define ELEMENT_TYPE int32_t
#define ROWS 4
#define COLUMNS 4

typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, COLUMNS&gt; MATRIX_A;
typedef Eigen::Matrix&lt;ELEMENT_TYPE, COLUMNS, ROWS&gt; MATRIX_B;
typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, ROWS&gt; MATRIX_C;

void matirx_multi_eigen(const MATRIX_A &amp;mat_1, const MATRIX_B &amp;mat_2, 
                        MATRIX_C &amp;mat_3)
{
    mat_3 = mat_1 * mat_2;
}
</code></pre>
  <p>
   上述代码中以 4 阶方阵的乘法运算为例，同时也适用于预处理变量
   <code>
    ROWS
   </code>
   和
   <code>
    COLUMNS
   </code>
   的值不相等的情况。比如：
   <code>
    ROWS
   </code>
   的值为 4、
   <code>
    COLUMNS
   </code>
   的值为 5时，
   <code>
    MATRIX_A
   </code>
   是一个 4x5 的矩阵，
   <code>
    MATRIX_B
   </code>
   是一个 5x4 的矩阵，满足矩阵乘法的条件。所以，上述函数仍然适用。
  </p>
  <p>
   另外，需要注意的是 Eigen 库中的矩阵是以列主序存储的。
  </p>
  <hr/>
  <h3 id="neon-4">
   <span id="jump使用NEON实现一个4阶方阵的乘法运算">
    使用 NEON 实现一个 4 阶方阵的乘法运算
   </span>
  </h3>
  <p>
   使用 NEON 实现一个 4 阶方阵的乘法运算，完整实现如下：
  </p>
  <pre><code>void matirx_multi_4x4_int32_neon(const int *mat_1, const int *mat_2, 
                                 int *mat_3, int rows)
{
    int32x4_t a_1 = vld1q_s32(mat_1);
    int32x4_t a_2 = vld1q_s32(mat_1 + rows);
    int32x4_t a_3 = vld1q_s32(mat_1 + 2 * rows);
    int32x4_t a_4 = vld1q_s32(mat_1 + 3 * rows);

    int32x4_t b_1 = vld1q_s32(mat_2);
    int32x4_t b_2 = vld1q_s32(mat_2 + rows);
    int32x4_t b_3 = vld1q_s32(mat_2 + 2 * rows);
    int32x4_t b_4 = vld1q_s32(mat_2 + 3 * rows);

    int32x4_t c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_1, 0));
    int32x4_t c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_1, 1));
    int32x4_t c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_1, 2));
    int32x4_t c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_1, 3));
    int32x4_t c_5 = vaddq_s32(c_1, c_2);
    int32x4_t c_6 = vaddq_s32(c_3, c_4);
    int32x4_t c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_2, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_2, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_2, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_2, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + rows, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_3, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_3, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_3, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_3, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + 2 * rows, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_4, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_4, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_4, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_4, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + 3 * rows, c_7);
}
</code></pre>
  <p>
   上述函数
   <code>
    matirx_multi_4x4_int32_neon()
   </code>
   的输入矩阵和输出矩阵都采用列主序的方式存储，与 Eigen 库保持一致。
  </p>
  <p>
   该函数的实现用到了 5 个
   <code>
    NEON Intrinsics
   </code>
   ，分别是
   <code>
    vld1q_s32
   </code>
   、
   <code>
    vgetq_lane_s32
   </code>
   、
   <code>
    vmulq_n_s32
   </code>
   、
   <code>
    vaddq_s32
   </code>
   和
   <code>
    vst1q_s32
   </code>
   ，它们都定义在
   <code>
    arm_neon.h
   </code>
   文件中。
  </p>
  <p>
   <code>
    vld1q_s32
   </code>
   的函数原型为
   <code>
    int32x4_t vld1q_s32 (const int32_t *a)
   </code>
   ，作用：将内存起始地址为 a 的后面 16 字节的内容赋值给类型为 int32x4_t 的向量。也就是说，在上述函数中
   <code>
    int32x4_t a_1 = vld1q_s32(mat_1);
   </code>
   的作用为：将矩阵 mat_1 的第 1 列元素的值赋值给变量 a_1。以此类推，
   <code>
    int32x4_t a_2 = vld1q_s32(mat_1 + rows);
   </code>
   的作用为：将矩阵 mat_1 的第 2 列元素的值赋值给变量 a_2。
  </p>
  <p>
   <code>
    vgetq_lane_s32
   </code>
   的函数原型为
   <code>
    int32_t vgetq_lane_s32 (int32x4_t __a, const int __b)
   </code>
   ，作用：返回类型为 int32x4_t 向量的第n个元素的值。也就是说，在上述函数中
   <code>
    vgetq_lane_s32(b_2, 0)
   </code>
   的作用为：取矩阵 mat_2 中位于第 1 列第 1 行的元素。以此类推，
   <code>
    vgetq_lane_s32(b_2, 1)
   </code>
   的作用为：取矩阵 mat_2 中位于第 1 列第 2 行的元素。
  </p>
  <p>
   <code>
    vmulq_n_s32
   </code>
   的函数原型为
   <code>
    int32x4_t vmulq_n_s32 (int32x4_t a, int32_t b)
   </code>
   ，作用：将一个向量类型为 int32x4_t 的变量 a 中的每个元素分别乘以一个数，这个数由参数 b 指定。也就是说，在上述函数中
   <code>
    int32x4_t c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_1, 0));
   </code>
   的作用为：将矩阵 mat_1 第 1 列的所有元素分别乘以矩阵 mat_2 的第 1 列第 1 行的元素，并将计算结果赋值给变量 c_1。以此类推，
   <code>
    int32x4_t c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_1, 1));
   </code>
   的作用为：将矩阵 mat_1 第 2 列的所有元素分别乘以矩阵 mat_2 的第 1 列第 2 行的元素，并将计算结果赋值给变量 c_2。
  </p>
  <p>
   <code>
    vaddq_s32
   </code>
   的函数原型为
   <code>
    int32x4_t vaddq_s32 (int32x4_t __a, int32x4_t __b)
   </code>
   ，作用：将两个类型为 int32x4_t 向量的对应位置元素相加。
  </p>
  <p>
   <code>
    vst1q_s32
   </code>
   的函数原型为
   <code>
    void vst1q_s32 (int32_t *a, int32x4_t b)
   </code>
   ，作用：将类型为 int32x4_t 向量（由参数b确定）的值存储到内存起始地址为 a 后面十六字节的内存中。也就是说，在上述函数中
   <code>
    vst1q_s32(mat_3, c_7);
   </code>
   的作用为：设置矩阵 mat_3 第一列所有元素的值。以此类推，
   <code>
    vst1q_s32(mat_3 + rows, c_7);
   </code>
   的作用为：设置矩阵 mat_3 第二列所有元素的值。
  </p>
  <p>
   下面讲解函数
   <code>
    matirx_multi_4x4_int32_neon()
   </code>
   每部分的实现。
  </p>
  <p>
   1）加载 4 阶方阵 mat_1
  </p>
  <pre><code>int32x4_t a_1 = vld1q_s32(mat_1);
int32x4_t a_2 = vld1q_s32(mat_1 + rows);
int32x4_t a_3 = vld1q_s32(mat_1 + 2 * rows);
int32x4_t a_4 = vld1q_s32(mat_1 + 3 * rows);
</code></pre>
  <p>
   由于函数
   <code>
    matirx_multi_4x4_int32_neon()
   </code>
   的输入矩阵采用列主序的方式存储。所以，这几行语句用于加载矩阵 mat_1 的每列元素到 4 个类型为 int32x4_t 的向量中，用于后面的计算。
  </p>
  <p>
   2）加载 4 阶方阵 mat_2
  </p>
  <pre><code>int32x4_t b_1 = vld1q_s32(mat_2);
int32x4_t b_2 = vld1q_s32(mat_2 + rows);
int32x4_t b_3 = vld1q_s32(mat_2 + 2 * rows);
int32x4_t b_4 = vld1q_s32(mat_2 + 3 * rows);
</code></pre>
  <p>
   同样地，这几行语句用于加载矩阵 mat_2 的每列元素到 4 个类型为 int32x4_t 的向量中，用于后面的计算。
  </p>
  <p>
   3）计算并保存方阵 mat_1、mat_2 乘积的第一列元素
  </p>
  <pre><code>int32x4_t c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_1, 0));
int32x4_t c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_1, 1));
int32x4_t c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_1, 2));
int32x4_t c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_1, 3));
int32x4_t c_5 = vaddq_s32(c_1, c_2);
int32x4_t c_6 = vaddq_s32(c_3, c_4);
int32x4_t c_7 = vaddq_s32(c_5, c_6);
vst1q_s32(mat_3, c_7);
</code></pre>
  <p>
   线性代数中矩阵乘法的运算规则为：矩阵 A 与矩阵 B 的乘积是一个矩阵 C。矩阵 C 的行数等于矩阵 A 的行数，矩阵 C 的列数等于矩阵 B 的列数，矩阵 C 的元素 cij（即矩阵 C 中第 i 行第 j 列的元素）等于矩阵 A 的第 i 行元素与矩阵 B 的第 j 列元素的乘积。
  </p>
  <p>
   变量 c_1 中有 4 个元素，依次为：
   <code>
    a11  * b11
   </code>
   、
   <code>
    a21 *  b11
   </code>
   、
   <code>
    a31 *  b11
   </code>
   、
   <code>
    a41 *  b11
   </code>
   。（aij 表示矩阵 mat_1 的第 i 行第 j 列的元素，bij 表示矩阵 mat_2 的第 i 行第 j 列的元素）
  </p>
  <p>
   变量 c_2 中有 4 个元素，依次为：
   <code>
    a12  * b21
   </code>
   、
   <code>
    a22 *  b21
   </code>
   、
   <code>
    a32 *  b21
   </code>
   、
   <code>
    a42 *  b21
   </code>
   。
  </p>
  <p>
   变量 c_3 中有 4 个元素，依次为：
   <code>
    a13  * b31
   </code>
   、
   <code>
    a23 *  b31
   </code>
   、
   <code>
    a33 *  b31
   </code>
   、
   <code>
    a43 *  b31
   </code>
   。
  </p>
  <p>
   变量 c_4 中有 4 个元素，依次为：
   <code>
    a14  * b41
   </code>
   、
   <code>
    a24 *  b41
   </code>
   、
   <code>
    a34 *  b41
   </code>
   、
   <code>
    a44 *  b41
   </code>
   。
  </p>
  <p>
   变量 c_7 中有 4 个元素，依次为：
   <code>
    a11  * b11 + a12  * b21 + a13  * b31 + a14  * b41
   </code>
   、
   <code>
    a21 *  b11 + a22 *  b21 + a23 *  b31 + a24 *  b41
   </code>
   、
   <code>
    a31 *  b11 + a32 *  b21 + a33 *  b31 + a34 *  b41
   </code>
   、
   <code>
    a41 *  b11 + a42 *  b21 + a43 *  b31 + a44 *  b41
   </code>
   。
  </p>
  <p>
   由于
   <code>
    c11 = a11  * b11 + a12  * b21 + a13  * b31 + a14  * b41
   </code>
   ，
   <code>
    c21 = a21 *  b11 + a22 *  b21 + a23 *  b31 + a24 *  b41
   </code>
   ，
   <code>
    c31 = a31 *  b11 + a32 *  b21 + a33 *  b31 + a34 *  b41
   </code>
   ，
   <code>
    c41 = a41 *  b11 + a42 *  b21 + a43 *  b31 + a44 *  b41
   </code>
   。所以，变量 c_7 中的 4 个元素即 c11、c21、c31、c41。也就是说， 变量 c_7 为方阵 mat_1、mat_2 乘积的第一列元素。矩阵乘积其他列元素的计算过程与之类似，后面不再赘述。
  </p>
  <p>
   4）计算并保存方阵 mat_1、mat_2 乘积的第二列元素
  </p>
  <pre><code>c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_2, 0));
c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_2, 1));
c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_2, 2));
c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_2, 3));
c_5 = vaddq_s32(c_1, c_2);
c_6 = vaddq_s32(c_3, c_4);
c_7 = vaddq_s32(c_5, c_6);
vst1q_s32(mat_3 + rows, c_7);
</code></pre>
  <p>
   5）计算并保存方阵 mat_1、mat_2 乘积的第三列元素
  </p>
  <pre><code>c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_3, 0));
c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_3, 1));
c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_3, 2));
c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_3, 3));
c_5 = vaddq_s32(c_1, c_2);
c_6 = vaddq_s32(c_3, c_4);
c_7 = vaddq_s32(c_5, c_6);
vst1q_s32(mat_3 + 2 * rows, c_7);
</code></pre>
  <p>
   6）计算并保存方阵 mat_1、mat_2 乘积的第四列元素
  </p>
  <pre><code>c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_4, 0));
c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_4, 1));
c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_4, 2));
c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_4, 3));
c_5 = vaddq_s32(c_1, c_2);
c_6 = vaddq_s32(c_3, c_4);
c_7 = vaddq_s32(c_5, c_6);
vst1q_s32(mat_3 + 3 * rows, c_7);
</code></pre>
  <p>
   完成程序为
   <code>
    main.cpp
   </code>
   ：
  </p>
  <pre><code>#include "arm_neon.h"
#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

#define ELEMENT_TYPE int32_t
#define ROWS 4
#define COLUMNS 4
#define ITERATION_COUNT 10000

typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, COLUMNS&gt; MATRIX_A;
typedef Eigen::Matrix&lt;ELEMENT_TYPE, COLUMNS, ROWS&gt; MATRIX_B;
typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, ROWS&gt; MATRIX_C;

template &lt;typename MatrixT&gt;
void init_mat(MatrixT &amp;mat, int offset)
{
    for (int i = 0; i &lt; mat.cols(); i++)
    {
        for (int j = 0; j &lt; mat.rows(); j++)
        {
            mat(j, i) = i + j + offset;
        }
    }
}

void init_mat(int *data, int rows, int cols, int offset)
{
    // 列主序
    for (int i = 0; i &lt; cols; ++i)
    {
        for (int j = 0; j &lt; rows; ++j)
        {
            *(data + i * rows + j) = i + j + offset;
        }
    }
}

void matirx_multi_eigen(const MATRIX_A &amp;mat_1, const MATRIX_B &amp;mat_2, 
                        MATRIX_C &amp;mat_3)
{
    mat_3 = mat_1 * mat_2;
}

void matirx_multi_4x4_int32_neon(const int *mat_1, const int *mat_2, 
                                 int *mat_3, int rows)
{
    int32x4_t a_1 = vld1q_s32(mat_1);
    int32x4_t a_2 = vld1q_s32(mat_1 + rows);
    int32x4_t a_3 = vld1q_s32(mat_1 + 2 * rows);
    int32x4_t a_4 = vld1q_s32(mat_1 + 3 * rows);

    int32x4_t b_1 = vld1q_s32(mat_2);
    int32x4_t b_2 = vld1q_s32(mat_2 + rows);
    int32x4_t b_3 = vld1q_s32(mat_2 + 2 * rows);
    int32x4_t b_4 = vld1q_s32(mat_2 + 3 * rows);

    int32x4_t c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_1, 0));
    int32x4_t c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_1, 1));
    int32x4_t c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_1, 2));
    int32x4_t c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_1, 3));
    int32x4_t c_5 = vaddq_s32(c_1, c_2);
    int32x4_t c_6 = vaddq_s32(c_3, c_4);
    int32x4_t c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_2, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_2, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_2, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_2, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + rows, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_3, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_3, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_3, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_3, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + 2 * rows, c_7);

    c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_4, 0));
    c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_4, 1));
    c_3 = vmulq_n_s32(a_3, vgetq_lane_s32(b_4, 2));
    c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_4, 3));
    c_5 = vaddq_s32(c_1, c_2);
    c_6 = vaddq_s32(c_3, c_4);
    c_7 = vaddq_s32(c_5, c_6);
    vst1q_s32(mat_3 + 3 * rows, c_7);
}

int main()
{
    MATRIX_A mat_1;
    MATRIX_B mat_2;
    MATRIX_C mat_3;

    init_mat(mat_1, 0);
    init_mat(mat_2, 1);

    int *mat_4 = new int[ROWS * COLUMNS];
    int *mat_5 = new int[COLUMNS * ROWS];
    int *mat_6 = new int[ROWS * ROWS];

    init_mat(mat_4, ROWS, COLUMNS, 0);
    init_mat(mat_5, COLUMNS, ROWS, 1);

    for (int i = 0; i &lt; ITERATION_COUNT; i++)
    {
        matirx_multi_eigen(mat_1, mat_2, mat_3);
    }

    for (int i = 0; i &lt; ITERATION_COUNT; i++)
    {
        matirx_multi_4x4_int32_neon(mat_4, mat_5, mat_6, ROWS);
    }

    delete [] mat_6;
    delete [] mat_5;
    delete [] mat_4;
    return 0;
}
</code></pre>
  <p>
   编译程序（On Jetson TX2）：
  </p>
  <pre><code>g++ -std=c++11 -I /home/test/eigen-3.3.7 -g -Og -o matrix_multi_Og matrix_multi.cpp
</code></pre>
  <p>
   注：
   <code>
    /home/test/eigen-3.3.7
   </code>
   为 eigen-3.3.7 的源码路径。
  </p>
  <p>
   统计两个版本的函数执行 10000 次的耗时，统计结果为：
  </p>
  <table>
   <thead>
    <tr>
     <th>
      启动程序方式
     </th>
     <th>
      第一次执行耗时(us)
     </th>
     <th>
      第二次执行耗时(us)
     </th>
     <th>
      第三次执行耗时(us)
     </th>
     <th>
      第四次执行耗时(us)
     </th>
     <th>
      第五次执行耗时(us)
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      ./main_Og
     </td>
     <td>
      <li>
       matirx_multi_eigen:3063
      </li>
      <li>
       matirx_multi_4x4_int32_neon:1507
      </li>
     </td>
     <td>
      <li>
       matirx_multi_eigen:3088
      </li>
      <li>
       matirx_multi_4x4_int32_neon:1504
      </li>
     </td>
     <td>
      <li>
       matirx_multi_eigen:2609
      </li>
      <li>
       matirx_multi_4x4_int32_neon:1026
      </li>
     </td>
     <td>
      <li>
       matirx_multi_eigen:3066
      </li>
      <li>
       matirx_multi_4x4_int32_neon:1447
      </li>
     </td>
     <td>
      <li>
       matirx_multi_eigen:2131
      </li>
      <li>
       matirx_multi_4x4_int32_neon:1002
      </li>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   从统计结果中可以看出，
   <code>
    matirx_multi_4x4_int32_neon()
   </code>
   函数的执行速度比
   <code>
    matirx_multi_eigen()
   </code>
   函数快 2 倍左右。
  </p>
  <p>
   Egien 库中也使用了 NEON 指令，这一点可以通过查看 main_Og 的汇编代码得到验证。
   <strong>
    那么导致这两个版本的执行速度不同的原因是什么呢？
   </strong>
   下面从 cache 的角度进行分析。
  </p>
  <p>
   统计 cache 性能数据：
  </p>
  <pre><code>--------------------------------------------------------------------------------
I1 cache:         16384 B, 64 B, 4-way associative
D1 cache:         16384 B, 64 B, 4-way associative
LL cache:         262144 B, 64 B, 8-way associative
Command:          ./main_Og
Data file:        cachegrind.out.22152
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   main.cpp
Auto-annotation:  on

--------------------------------------------------------------------------------
       Ir  I1mr  ILmr        Dr   D1mr  DLmr      Dw  D1mw  DLmw 
--------------------------------------------------------------------------------
3,855,912 1,704 1,434 1,223,769 16,168 8,634 481,210 2,505 1,479  PROGRAM TOTALS

--------------------------------------------------------------------------------
     Ir I1mr ILmr      Dr  D1mr  DLmr     Dw  D1mw DLmw  file:function
--------------------------------------------------------------------------------
600,000    4    4 210,000     0     0 80,000     0    0  /usr/lib/gcc/aarch64-linux-gnu/5/include/arm_neon.h:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
570,000    4    3  80,000     3     0 40,000     1    1  /usr/lib/gcc/aarch64-linux-gnu/5/include/arm_neon.h:matirx_multi_4x4_int32_neon(int const*, int const*, int*, int)
548,097   11   10 149,642 2,055 1,702 50,569    22    9  /build/glibc-BinVK7/glibc-2.23/elf/dl-lookup.c:_dl_lookup_symbol_x
540,520   45   41 192,656 5,120   951 94,214    35    8  /build/glibc-BinVK7/glibc-2.23/elf/dl-lookup.c:do_lookup_x
220,000    2    2 140,000     0     0 50,000     0    0  /home/test/eigen-3.3.7/Eigen/src/Core/CoreEvaluators.h:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
211,533   28   28  48,140 3,389 2,964 20,629 1,745  887  /build/glibc-BinVK7/glibc-2.23/elf/../sysdeps/aarch64/dl-machine.h:_dl_relocate_object
190,079    8    8       9     2     0      7     0    0  /home/test3/main.cpp:main
160,000    1    1  60,000     0     0 40,000     0    0  /home/test3/main.cpp:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
150,000    0    0 150,000     0     0      0     0    0  /home/test/eigen-3.3.7/Eigen/src/Core/arch/NEON/PacketMath.h:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
130,000    1    1  80,000     0     0 40,000     0    0  /home/test/eigen-3.3.7/Eigen/src/Core/AssignEvaluator.h:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
109,117    8    6  37,818   377   243 14,749    21    2  /build/glibc-BinVK7/glibc-2.23/elf/dl-lookup.c:check_match
103,170    7    7  14,700   250    90      0     0    0  /build/glibc-BinVK7/glibc-2.23/string/../sysdeps/aarch64/strcmp.S:strcmp
 56,746    3    3  16,086 2,185 1,019  3,210     2    0  /build/glibc-BinVK7/glibc-2.23/elf/do-rel.h:_dl_relocate_object
 50,000    0    0       0     0     0 30,000     0    0  /home/test/eigen-3.3.7/Eigen/src/Core/ProductEvaluators.h:matirx_multi_eigen(Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; const&amp;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;&amp;)
 50,000    0    0       0     0     0      0     0    0  /home/test3/main.cpp:matirx_multi_4x4_int32_neon(int const*, int const*, int*, int)
 44,112    8    8  13,412 1,022   985     12     1    0  /build/glibc-BinVK7/glibc-2.23/elf/dl-addr.c:_dl_addr
 10,800    8    8   3,270     8     0    360     0    0  ???:std::locale::_Impl::_M_install_facet(std::locale::id const*, std::locale::facet const*)
 10,000    0    0       0     0     0      0     0    0  /home/test/eigen-3.3.7/Eigen/src/Core/GeneralProduct.h:Eigen::Product&lt;Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;, Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt;, 1&gt; const Eigen::MatrixBase&lt;Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; &gt;::lazyProduct&lt;Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; &gt;(Eigen::MatrixBase&lt;Eigen::Matrix&lt;int, 4, 4, 0, 4, 4&gt; &gt; const&amp;) const
  7,273    6    5   3,012   423   142    624     3    1  /build/glibc-BinVK7/glibc-2.23/elf/dl-runtime.c:_dl_fixup
  6,004  236  193   1,528   217    31    574    26   18  ???:???
  5,740    2    2   2,286    74     6  1,136     2    2  /build/glibc-BinVK7/glibc-2.23/elf/dl-misc.c:_dl_name_match_p
  5,504    3    3   1,664     5     4    640     0    0  /build/glibc-BinVK7/glibc-2.23/wcsmbs/btowc.c:btowc

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib/gcc/aarch64-linux-gnu/5/include/arm_neon.h
--------------------------------------------------------------------------------
     Ir I1mr ILmr      Dr D1mr DLmr      Dw D1mw DLmw 

-- line 671 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vaddq_s16 (int16x8_t __a, int16x8_t __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __a + __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vaddq_s32 (int32x4_t __a, int32x4_t __b)
      .    .    .       .    .    .       .    .    .  {
120,000    1    0       0    0    0       0    0    0    return __a + __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vaddq_s64 (int64x2_t __a, int64x2_t __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __a + __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 687 ----------------------------------------
-- line 1284 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vmulq_s16 (int16x8_t __a, int16x8_t __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __a * __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmulq_s32 (int32x4_t __a, int32x4_t __b)
      .    .    .       .    .    .       .    .    .  {
 40,000    0    0       0    0    0       0    0    0    return __a * __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmulq_f32 (float32x4_t __a, float32x4_t __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __a * __b;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 1300 ----------------------------------------
-- line 2849 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vgetq_lane_s16 (int16x8_t __a, const int __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __aarch64_vget_lane_any (__a, __b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vgetq_lane_s32 (int32x4_t __a, const int __b)
      .    .    .       .    .    .       .    .    .  {
160,000    2    2       0    0    0       0    0    0    return __aarch64_vget_lane_any (__a, __b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int64_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vgetq_lane_s64 (int64x2_t __a, const int __b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __aarch64_vget_lane_any (__a, __b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 2865 ----------------------------------------
-- line 6944 ----------------------------------------
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmlaq_s32 (int32x4_t a, int32x4_t b, int32x4_t c)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    int32x4_t result;
      .    .    .       .    .    .       .    .    .    __asm__ ("mla %0.4s, %2.4s, %3.4s"
      .    .    .       .    .    .       .    .    .             : "=w"(result)
      .    .    .       .    .    .       .    .    .             : "0"(a), "w"(b), "w"(c)
120,000    0    0       0    0    0       0    0    0             : /* No clobbers */);
      .    .    .       .    .    .       .    .    .    return result;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmlaq_u8 (uint8x16_t a, uint8x16_t b, uint8x16_t c)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    uint8x16_t result;
      .    .    .       .    .    .       .    .    .    __asm__ ("mla %0.16b, %2.16b, %3.16b"
-- line 6960 ----------------------------------------
-- line 8478 ----------------------------------------
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmulq_n_s32 (int32x4_t a, int32_t b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    int32x4_t result;
      .    .    .       .    .    .       .    .    .    __asm__ ("mul %0.4s,%1.4s,%2.s[0]"
      .    .    .       .    .    .       .    .    .             : "=w"(result)
      .    .    .       .    .    .       .    .    .             : "w"(a), "w"(b)
160,000    0    0       0    0    0       0    0    0             : /* No clobbers */);
      .    .    .       .    .    .       .    .    .    return result;
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vmulq_n_u16 (uint16x8_t a, uint16_t b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    uint16x8_t result;
      .    .    .       .    .    .       .    .    .    __asm__ ("mul %0.8h,%1.8h,%2.h[0]"
-- line 8494 ----------------------------------------
-- line 14183 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vdupq_n_s16 (int32_t __a)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return (int16x8_t) {__a, __a, __a, __a, __a, __a, __a, __a};
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vdupq_n_s32 (int32_t __a)
      .    .    .       .    .    .       .    .    .  {
160,000    2    2  10,000    0    0       0    0    0    return (int32x4_t) {__a, __a, __a, __a};
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vdupq_n_s64 (int64_t __a)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return (int64x2_t) {__a, __a};
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 14199 ----------------------------------------
-- line 15363 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vld1q_s16 (const int16_t *a)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __builtin_aarch64_ld1v8hi ((const __builtin_aarch64_simd_hi *) a);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vld1q_s32 (const int32_t *a)
      .    .    .       .    .    .       .    .    .  {
280,000    2    2 280,000    3    0       0    0    0    return __builtin_aarch64_ld1v4si ((const __builtin_aarch64_simd_si *) a);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vld1q_s64 (const int64_t *a)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    return __builtin_aarch64_ld1v2di ((const __builtin_aarch64_simd_di *) a);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 15379 ----------------------------------------
-- line 22902 ----------------------------------------
      .    .    .       .    .    .       .    .    .  vst1q_s16 (int16_t *a, int16x8_t b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    __builtin_aarch64_st1v8hi ((__builtin_aarch64_simd_hi *) a, b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline void __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vst1q_s32 (int32_t *a, int32x4_t b)
      .    .    .       .    .    .       .    .    .  {
130,000    1    1       0    0    0 120,000    1    1    __builtin_aarch64_st1v4si ((__builtin_aarch64_simd_si *) a, b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
      .    .    .       .    .    .       .    .    .  __extension__ static __inline void __attribute__ ((__always_inline__))
      .    .    .       .    .    .       .    .    .  vst1q_s64 (int64_t *a, int64x2_t b)
      .    .    .       .    .    .       .    .    .  {
      .    .    .       .    .    .       .    .    .    __builtin_aarch64_st1v2di ((__builtin_aarch64_simd_di *) a, b);
      .    .    .       .    .    .       .    .    .  }
      .    .    .       .    .    .       .    .    .  
-- line 22918 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test3/main.cpp
--------------------------------------------------------------------------------
    Ir I1mr ILmr     Dr D1mr DLmr     Dw D1mw DLmw 

-- line 12 ----------------------------------------
     .    .    .      .    .    .      .    .    .  #define COLUMNS ROWS
     .    .    .      .    .    .      .    .    .  #define ITERATION_COUNT 10000
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, COLUMNS&gt; MATRIX_A;
     .    .    .      .    .    .      .    .    .  typedef Eigen::Matrix&lt;ELEMENT_TYPE, COLUMNS, ROWS&gt; MATRIX_B;
     .    .    .      .    .    .      .    .    .  typedef Eigen::Matrix&lt;ELEMENT_TYPE, ROWS, ROWS&gt; MATRIX_C;
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  template &lt;typename MatrixT&gt;
     4    1    1      0    0    0      4    0    0  void init_mat(MatrixT &amp;mat, int offset)
     .    .    .      .    .    .      .    .    .  {
    46    0    0      0    0    0      0    0    0      for (int i = 0; i &lt; mat.cols(); i++)
     .    .    .      .    .    .      .    .    .      {
   144    1    1      0    0    0      0    0    0          for (int j = 0; j &lt; mat.rows(); j++)
     .    .    .      .    .    .      .    .    .          {
   160    0    0      0    0    0     32    0    0              mat(j, i) = i + j + offset;
     .    .    .      .    .    .      .    .    .          }
     .    .    .      .    .    .      .    .    .      }
     4    0    0      4    0    0      0    0    0  }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  void init_mat(int *data, int rows, int cols, int offset)
     .    .    .      .    .    .      .    .    .  {
     .    .    .      .    .    .      .    .    .      // 列主序
    48    0    0      0    0    0      0    0    0      for (int i = 0; i &lt; cols; ++i)
     .    .    .      .    .    .      .    .    .      {
   144    0    0      0    0    0      0    0    0          for (int j = 0; j &lt; rows; ++j)
     .    .    .      .    .    .      .    .    .          {
   192    1    1      0    0    0     32    0    0              *(data + i * rows + j) = i + j + offset;
     .    .    .      .    .    .      .    .    .          }
     .    .    .      .    .    .      .    .    .      }
     .    .    .      .    .    .      .    .    .  }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  void matirx_multi_eigen(const MATRIX_A &amp;mat_1, const MATRIX_B &amp;mat_2, 
     .    .    .      .    .    .      .    .    .                          MATRIX_C &amp;mat_3)
80,000    1    1 10,000    0    0 40,000    0    0  {
     .    .    .      .    .    .      .    .    .      mat_3 = mat_1 * mat_2;
80,000    0    0 50,000    0    0      0    0    0  }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  void matirx_multi_4x4_int32_neon(const int *mat_1, const int *mat_2, 
     .    .    .      .    .    .      .    .    .                                   int *mat_3, int rows)
     .    .    .      .    .    .      .    .    .  {
     .    .    .      .    .    .      .    .    .      int32x4_t a_1 = vld1q_s32(mat_1);
20,000    0    0      0    0    0      0    0    0      int32x4_t a_2 = vld1q_s32(mat_1 + rows);
10,000    0    0      0    0    0      0    0    0      int32x4_t a_3 = vld1q_s32(mat_1 + 2 * rows);
20,000    0    0      0    0    0      0    0    0      int32x4_t a_4 = vld1q_s32(mat_1 + 3 * rows);
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .      int32x4_t b_1 = vld1q_s32(mat_2);
     .    .    .      .    .    .      .    .    .      int32x4_t b_2 = vld1q_s32(mat_2 + rows);
     .    .    .      .    .    .      .    .    .      int32x4_t b_3 = vld1q_s32(mat_2 + 2 * rows);
     .    .    .      .    .    .      .    .    .      int32x4_t b_4 = vld1q_s32(mat_2 + 3 * rows);
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .      int32x4_t c_1 = vmulq_n_s32(a_1, vgetq_lane_s32(b_1, 0));
     .    .    .      .    .    .      .    .    .      int32x4_t c_2 = vmulq_n_s32(a_2, vgetq_lane_s32(b_1, 1));
-- line 63 ----------------------------------------
-- line 92 ----------------------------------------
     .    .    .      .    .    .      .    .    .      c_4 = vmulq_n_s32(a_4, vgetq_lane_s32(b_4, 3));
     .    .    .      .    .    .      .    .    .      c_5 = vaddq_s32(c_1, c_2);
     .    .    .      .    .    .      .    .    .      c_6 = vaddq_s32(c_3, c_4);
     .    .    .      .    .    .      .    .    .      c_7 = vaddq_s32(c_5, c_6);
     .    .    .      .    .    .      .    .    .      vst1q_s32(mat_3 + 3 * rows, c_7);
     .    .    .      .    .    .      .    .    .  }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .  int main()
     8    2    2      1    0    0      7    0    0  {
     .    .    .      .    .    .      .    .    .      MATRIX_A mat_1;
     .    .    .      .    .    .      .    .    .      MATRIX_B mat_2;
     .    .    .      .    .    .      .    .    .      MATRIX_C mat_3;
     .    .    .      .    .    .      .    .    .  
     2    0    0      0    0    0      0    0    0      init_mat(mat_1, 0);
     3    0    0      0    0    0      0    0    0      init_mat(mat_2, 1);
     .    .    .      .    .    .      .    .    .  
     3    0    0      0    0    0      0    0    0      int *mat_4 = new int[ROWS * COLUMNS];
     3    0    0      0    0    0      0    0    0      int *mat_5 = new int[COLUMNS * ROWS];
     3    0    0      0    0    0      0    0    0      int *mat_6 = new int[ROWS * ROWS];
     .    .    .      .    .    .      .    .    .  
     5    1    1      0    0    0      0    0    0      init_mat(mat_4, ROWS, COLUMNS, 0);
     5    0    0      0    0    0      0    0    0      init_mat(mat_5, COLUMNS, ROWS, 1);
     .    .    .      .    .    .      .    .    .  
50,004    1    1      0    0    0      0    0    0      for (int i = 0; i &lt; ITERATION_COUNT; i++)
     .    .    .      .    .    .      .    .    .      {
40,000    0    0      0    0    0      0    0    0           matirx_multi_eigen(mat_1, mat_2, mat_3);
     .    .    .      .    .    .      .    .    .      }
     .    .    .      .    .    .      .    .    .  
50,004    1    1      0    0    0      0    0    0      for (int i = 0; i &lt; ITERATION_COUNT; i++)
     .    .    .      .    .    .      .    .    .      {
50,000    0    0      0    0    0      0    0    0           matirx_multi_4x4_int32_neon(mat_4, mat_5, mat_6, ROWS);
     .    .    .      .    .    .      .    .    .      }
     .    .    .      .    .    .      .    .    .  
     3    0    0      0    0    0      0    0    0      delete [] mat_6;
     3    1    1      0    0    0      0    0    0      delete [] mat_5;
     3    0    0      0    0    0      0    0    0      delete [] mat_4;
     .    .    .      .    .    .      .    .    .      return 0;
    28    4    3     13    2    0      5    0    0  }

--------------------------------------------------------------------------------
-- User-annotated source: main.cpp
--------------------------------------------------------------------------------
  No information has been collected for main.cpp

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test/eigen-3.3.7/Eigen/src/Core/ProductEvaluators.h
--------------------------------------------------------------------------------
    Ir I1mr ILmr Dr D1mr DLmr     Dw D1mw DLmw 

-- line 389 ----------------------------------------
     .    .    .  .    .    .      .    .    .  {
     .    .    .  .    .    .      .    .    .    typedef typename Product&lt;Lhs,Rhs&gt;::Scalar Scalar;
     .    .    .  .    .    .      .    .    .    
     .    .    .  .    .    .      .    .    .    template&lt;typename Dst&gt;
     .    .    .  .    .    .      .    .    .    static EIGEN_STRONG_INLINE void evalTo(Dst&amp; dst, const Lhs&amp; lhs, const Rhs&amp; rhs)
     .    .    .  .    .    .      .    .    .    {
     .    .    .  .    .    .      .    .    .      // Same as: dst.noalias() = lhs.lazyProduct(rhs);
     .    .    .  .    .    .      .    .    .      // but easier on the compiler side
10,000    0    0  0    0    0      0    0    0      call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::assign_op&lt;typename Dst::Scalar,Scalar&gt;());
     .    .    .  .    .    .      .    .    .    }
     .    .    .  .    .    .      .    .    .    
     .    .    .  .    .    .      .    .    .    template&lt;typename Dst&gt;
     .    .    .  .    .    .      .    .    .    static EIGEN_STRONG_INLINE void addTo(Dst&amp; dst, const Lhs&amp; lhs, const Rhs&amp; rhs)
     .    .    .  .    .    .      .    .    .    {
     .    .    .  .    .    .      .    .    .      // dst.noalias() += lhs.lazyProduct(rhs);
     .    .    .  .    .    .      .    .    .      call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::add_assign_op&lt;typename Dst::Scalar,Scalar&gt;());
     .    .    .  .    .    .      .    .    .    }
-- line 405 ----------------------------------------
-- line 443 ----------------------------------------
     .    .    .  .    .    .      .    .    .  
     .    .    .  .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     .    .    .  .    .    .      .    .    .    explicit product_evaluator(const XprType&amp; xpr)
     .    .    .  .    .    .      .    .    .      : m_lhs(xpr.lhs()),
     .    .    .  .    .    .      .    .    .        m_rhs(xpr.rhs()),
     .    .    .  .    .    .      .    .    .        m_lhsImpl(m_lhs),     // FIXME the creation of the evaluator objects should result in a no-op, but check that!
     .    .    .  .    .    .      .    .    .        m_rhsImpl(m_rhs),     //       Moreover, they are only useful for the packet path, so we could completely disable them when not needed,
     .    .    .  .    .    .      .    .    .                              //       or perhaps declare them on the fly on the packet method... We have experiment to check what's best.
40,000    0    0  0    0    0 30,000    0    0        m_innerDim(xpr.lhs().cols())
     .    .    .  .    .    .      .    .    .    {
     .    .    .  .    .    .      .    .    .      EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits&lt;Scalar&gt;::MulCost);
     .    .    .  .    .    .      .    .    .      EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits&lt;Scalar&gt;::AddCost);
     .    .    .  .    .    .      .    .    .      EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     .    .    .  .    .    .      .    .    .  #if 0
     .    .    .  .    .    .      .    .    .      std::cerr &lt;&lt; "LhsOuterStrideBytes=  " &lt;&lt; LhsOuterStrideBytes &lt;&lt; "\n";
     .    .    .  .    .    .      .    .    .      std::cerr &lt;&lt; "RhsOuterStrideBytes=  " &lt;&lt; RhsOuterStrideBytes &lt;&lt; "\n";
     .    .    .  .    .    .      .    .    .      std::cerr &lt;&lt; "LhsAlignment=         " &lt;&lt; LhsAlignment &lt;&lt; "\n";
-- line 459 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test/eigen-3.3.7/Eigen/src/Core/AssignEvaluator.h
--------------------------------------------------------------------------------
    Ir I1mr ILmr     Dr D1mr DLmr     Dw D1mw DLmw 

-- line 603 ----------------------------------------
     .    .    .      .    .    .      .    .    .    typedef DstEvaluatorTypeT DstEvaluatorType;
     .    .    .      .    .    .      .    .    .    typedef SrcEvaluatorTypeT SrcEvaluatorType;
     .    .    .      .    .    .      .    .    .    typedef typename DstEvaluatorType::Scalar Scalar;
     .    .    .      .    .    .      .    .    .    typedef copy_using_evaluator_traits&lt;DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor&gt; AssignmentTraits;
     .    .    .      .    .    .      .    .    .    typedef typename AssignmentTraits::PacketType PacketType;
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorType &amp;dst, const SrcEvaluatorType &amp;src, const Functor &amp;func, DstXprType&amp; dstExpr)
50,000    1    1      0    0    0 40,000    0    0      : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      #ifdef EIGEN_DEBUG_ASSIGN
     .    .    .      .    .    .      .    .    .      AssignmentTraits::debug();
     .    .    .      .    .    .      .    .    .      #endif
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC Index size() const        { return m_dstExpr.size(); }
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC Index innerSize() const   { return m_dstExpr.innerSize(); }
-- line 619 ----------------------------------------
-- line 644 ----------------------------------------
     .    .    .      .    .    .      .    .    .      Index col = colIndexByOuterInner(outer, inner); 
     .    .    .      .    .    .      .    .    .      assignCoeff(row, col);
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    template&lt;int StoreMode, int LoadMode, typename PacketType&gt;
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)
     .    .    .      .    .    .      .    .    .    {
80,000    0    0 80,000    0    0      0    0    0      m_functor.template assignPacket&lt;StoreMode&gt;(&amp;m_dst.coeffRef(row,col), m_src.template packet&lt;LoadMode,PacketType&gt;(row,col));
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    template&lt;int StoreMode, int LoadMode, typename PacketType&gt;
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      m_functor.template assignPacket&lt;StoreMode&gt;(&amp;m_dst.coeffRef(index), m_src.template packet&lt;LoadMode,PacketType&gt;(index));
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .    
-- line 660 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test/eigen-3.3.7/Eigen/src/Core/CoreEvaluators.h
--------------------------------------------------------------------------------
    Ir I1mr ILmr     Dr D1mr DLmr     Dw D1mw DLmw 

-- line 147 ----------------------------------------
     .    .    .      .    .    .      .    .    .        m_outerStride(IsVectorAtCompileTime  ? 0 
     .    .    .      .    .    .      .    .    .                                             : int(IsRowMajor) ? ColsAtCompileTime 
     .    .    .      .    .    .      .    .    .                                             : RowsAtCompileTime)
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .    
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType&amp; m)
80,000    1    1      0    0    0 50,000    0    0      : m_data(m.data()), m_outerStride(IsVectorAtCompileTime ? 0 : m.outerStride()) 
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    CoeffReturnType coeff(Index row, Index col) const
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      if (IsRowMajor)
     .    .    .      .    .    .      .    .    .        return m_data[row * m_outerStride.value() + col];
     .    .    .      .    .    .      .    .    .      else
40,000    1    1 40,000    0    0      0    0    0        return m_data[row + col * m_outerStride.value()];
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    CoeffReturnType coeff(Index index) const
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      return m_data[index];
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    Scalar&amp; coeffRef(Index row, Index col)
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      if (IsRowMajor)
     .    .    .      .    .    .      .    .    .        return const_cast&lt;Scalar*&gt;(m_data)[row * m_outerStride.value() + col];
     .    .    .      .    .    .      .    .    .      else
50,032    1    1 50,000    0    0      0    0    0        return const_cast&lt;Scalar*&gt;(m_data)[row + col * m_outerStride.value()];
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    Scalar&amp; coeffRef(Index index)
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      return const_cast&lt;Scalar*&gt;(m_data)[index];
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    template&lt;int LoadMode, typename PacketType&gt;
     .    .    .      .    .    .      .    .    .    EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    PacketType packet(Index row, Index col) const
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      if (IsRowMajor)
     .    .    .      .    .    .      .    .    .        return ploadt&lt;PacketType, LoadMode&gt;(m_data + row * m_outerStride.value() + col);
     .    .    .      .    .    .      .    .    .      else
50,000    0    0 50,000    0    0      0    0    0        return ploadt&lt;PacketType, LoadMode&gt;(m_data + row + col * m_outerStride.value());
     .    .    .      .    .    .      .    .    .    }
     .    .    .      .    .    .      .    .    .  
     .    .    .      .    .    .      .    .    .    template&lt;int LoadMode, typename PacketType&gt;
     .    .    .      .    .    .      .    .    .    EIGEN_STRONG_INLINE
     .    .    .      .    .    .      .    .    .    PacketType packet(Index index) const
     .    .    .      .    .    .      .    .    .    {
     .    .    .      .    .    .      .    .    .      return ploadt&lt;PacketType, LoadMode&gt;(m_data + index);
     .    .    .      .    .    .      .    .    .    }
-- line 205 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test/eigen-3.3.7/Eigen/src/Core/GeneralProduct.h
--------------------------------------------------------------------------------
    Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 443 ----------------------------------------
     .    .    .  .    .    .  .    .    .    //    * for a coeff-wise product use: v1.cwiseProduct(v2)
     .    .    .  .    .    .  .    .    .    EIGEN_STATIC_ASSERT(ProductIsValid || !(AreVectors &amp;&amp; SameSizes),
     .    .    .  .    .    .  .    .    .      INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS)
     .    .    .  .    .    .  .    .    .    EIGEN_STATIC_ASSERT(ProductIsValid || !(SameSizes &amp;&amp; !AreVectors),
     .    .    .  .    .    .  .    .    .      INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION)
     .    .    .  .    .    .  .    .    .    EIGEN_STATIC_ASSERT(ProductIsValid || SameSizes, INVALID_MATRIX_PRODUCT)
     .    .    .  .    .    .  .    .    .  
     .    .    .  .    .    .  .    .    .    return Product&lt;Derived,OtherDerived,LazyProduct&gt;(derived(), other.derived());
10,000    0    0  0    0    0  0    0    0  }
     .    .    .  .    .    .  .    .    .  
     .    .    .  .    .    .  .    .    .  } // end namespace Eigen
     .    .    .  .    .    .  .    .    .  
     .    .    .  .    .    .  .    .    .  #endif // EIGEN_PRODUCT_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/test/eigen-3.3.7/Eigen/src/Core/arch/NEON/PacketMath.h
--------------------------------------------------------------------------------
     Ir I1mr ILmr      Dr D1mr DLmr Dw D1mw DLmw 

-- line 138 ----------------------------------------
      .    .    .       .    .    .  .    .    .  EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }
      .    .    .       .    .    .  .    .    .  EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }
      .    .    .       .    .    .  .    .    .  #endif
      .    .    .       .    .    .  .    .    .  
      .    .    .       .    .    .  .    .    .  template&lt;&gt; struct unpacket_traits&lt;Packet4f&gt; { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };
      .    .    .       .    .    .  .    .    .  template&lt;&gt; struct unpacket_traits&lt;Packet4i&gt; { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };
      .    .    .       .    .    .  .    .    .  
      .    .    .       .    .    .  .    .    .  template&lt;&gt; EIGEN_STRONG_INLINE Packet4f pset1&lt;Packet4f&gt;(const float&amp;  from) { return vdupq_n_f32(from); }
150,000    0    0 150,000    0    0  0    0    0  template&lt;&gt; EIGEN_STRONG_INLINE Packet4i pset1&lt;Packet4i&gt;(const int32_t&amp;    from)   { return vdupq_n_s32(from); }
      .    .    .       .    .    .  .    .    .  
      .    .    .       .    .    .  .    .    .  template&lt;&gt; EIGEN_STRONG_INLINE Packet4f plset&lt;Packet4f&gt;(const float&amp; a)
      .    .    .       .    .    .  .    .    .  {
      .    .    .       .    .    .  .    .    .    const float f[] = {0, 1, 2, 3};
      .    .    .       .    .    .  .    .    .    Packet4f countdown = vld1q_f32(f);
      .    .    .       .    .    .  .    .    .    return vaddq_f32(pset1&lt;Packet4f&gt;(a), countdown);
      .    .    .       .    .    .  .    .    .  }
      .    .    .       .    .    .  .    .    .  template&lt;&gt; EIGEN_STRONG_INLINE Packet4i plset&lt;Packet4i&gt;(const int32_t&amp; a)
-- line 154 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-BinVK7/glibc-2.23/elf/do-rel.h
  /build/glibc-BinVK7/glibc-2.23/wcsmbs/btowc.c
  /build/glibc-BinVK7/glibc-2.23/elf/dl-runtime.c
  /build/glibc-BinVK7/glibc-2.23/elf/dl-addr.c
  /build/glibc-BinVK7/glibc-2.23/elf/dl-lookup.c
  /build/glibc-BinVK7/glibc-2.23/string/../sysdeps/aarch64/strcmp.S
  /build/glibc-BinVK7/glibc-2.23/elf/dl-misc.c
  /build/glibc-BinVK7/glibc-2.23/elf/../sysdeps/aarch64/dl-machine.h

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
55    2    2 59    0    0 58    0    0  percentage of events annotated
</code></pre>
  <p>
   分析统计结果：
  </p>
  <table>
   <thead>
    <tr>
     <th>
      函数名称
     </th>
     <th>
      内存读操作数量(Dr列)
     </th>
     <th>
      一级数据缓存读不命中次数(D1mr列)
     </th>
     <th>
      最后一级数据缓存读不命中次数(DLmr列)
     </th>
     <th>
      内存写操作数量(Dw列)
     </th>
     <th>
      一级数据缓存写不命中次数(D1mw列)
     </th>
     <th>
      最后一级数据缓存写不命中次数(DLmw列)
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      matirx_multi_eigen
     </td>
     <td>
      640,000
     </td>
     <td>
      0
     </td>
     <td>
      0
     </td>
     <td>
      240,000
     </td>
     <td>
      0
     </td>
     <td>
      0
     </td>
    </tr>
    <tr>
     <td>
      matirx_multi_4x4_int32_neon
     </td>
     <td>
      80,000
     </td>
     <td>
      3
     </td>
     <td>
      0
     </td>
     <td>
      40,000
     </td>
     <td>
      1
     </td>
     <td>
      1
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   可以看出，
   <code>
    matirx_multi_4x4_int32_neon
   </code>
   函数的内存读操作数量和内存写操作数量分别为
   <code>
    matirx_multi_eigen
   </code>
   函数的 0.125 倍、0.167 倍，其他的基本相同。因此，从 cache 的角度来看，
   <code>
    matirx_multi_4x4_int32_neon
   </code>
   函数比 Eigen 库的实现大大减少了内存读写操作数量，从而改善程序性能。
  </p>
  <hr/>
  <p>
   <font size="4">
    <strong>
     下一篇：
    </strong>
    <a href="https://csstormq.github.io/#jump性能优化">
     性能优化之目录
    </a>
   </font>
  </p>
  <p>
   <font size="4">
    <strong>
     上一篇：
    </strong>
    <a href="https://csstormq.github.io/blog/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%885%EF%BC%89%EF%BC%9ANEON%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B9%8BRGBA%E5%88%B0RGB%EF%BC%88aarch64%E7%89%88%EF%BC%89">
     性能优化篇（5）：NEON 优化案例——图像转换之 RGBA 到 RGB（aarch64版）
    </a>
   </font>
  </p>
  <p>
  </p>
  <p align="center">
   <font size="4">
    <a href="https://csstormq.github.io">
     <strong>
      首页
     </strong>
    </a>
   </font>
  </p>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
